use import std.string
use import std.array
use import std.map
use import std.unicode
use import std.mem.std_heap_allocator
use import std.rc

io  :: import std.io
fmt :: import std.fmt

use import glfw
use import glfw_hl

use import editor
use import chim
use import gap_buffer
use import commands

#export_scope

debug_parser :: false

KeyEventType :: enum #copy {
    Char : char
    Space
    Escape
    Enter
    Tab
    Backspace
    Insert
    Delete
    Right
    Left
    Down
    Up
    PageUp
    PageDown
    Home
    End
    CapsLock
    ScrollLock
    NumLock
    PrintScreen
    Pause
    F1
    F2
    F3
    F4
    F5
    F6
    F7
    F8
    F9
    F10
    F11
    F12
    F13
    F14
    F15
    F16
    F17
    F18
    F19
    F20
    F21
    F22
    F23
    F24
    F25
    Kp0
    Kp1
    Kp2
    Kp3
    Kp4
    Kp5
    Kp6
    Kp7
    Kp8
    Kp9
    KpDecimal
    KpDivide
    KpMultiply
    KpSubtract
    KpAdd
    KpEnter
    KpEqual
}

KeyEvent :: struct #copy {
    mods    : GlfwMod
    typ     : KeyEventType
}

ParserState :: enum #copy {
    InProgress
    Success
    Error
}

Parser :: trait {
    state           :: (&Self) -> ParserState;
    advance         :: (&mut Self, event: KeyEvent);
    clone           :: (&Self) -> Rc[Parser];
    build_command   :: (&Self) -> Result[Command, String];
    get_values      :: (&Self, chars: &mut Array[Argument]);
    accepts_numbers :: (&Self) -> bool;
}

CharParser :: struct {
    _state      : ParserState
    character   := '`0'
}

impl CharParser {
    new :: () -> Rc[Parser] {
        return Rc[Parser].new(CharParser(.InProgress))
    }
}

impl Parser for CharParser {
    state :: (&Self) -> ParserState {
        return self._state
    }

    accepts_numbers :: (&Self) -> bool {
        return true
    }

    build_command :: (&Self) -> Result[Command, String] {
        return Err(fmt.format("No command specified"))
    }

    get_values :: (&Self, args: &mut Array[Argument]) {
        match self._state {
            .Success -> {
                args.add(Argument.Char(self.character))
            }
            _ -> {}
        }
    }

    clone :: (&mut Self) -> Rc[Parser] {
        return Self.new()
    }

    advance :: (&mut Self, event: KeyEvent) {
        parser_log("CharParser['{}'].advance({})", [event])

        match self._state {
            .InProgress -> {
                match event.typ {
                    .Char($ch) -> {
                        parser_log("CharParser['{}'].advance({}).InProgress '{}'", [event, ch])
                        if event.mods == .Shift {
                            self.character = ch.to_upper()
                            self._state = .Success
                        } else if event.mods == .None {
                            self.character = ch
                            self._state = .Success
                        } else {
                            self._state = .Error
                        }
                    }

                    .Space -> {
                        if event.mods == .None {
                            self.character = ' '
                            self._state = .Success
                        } else {
                            self._state = .Error
                        }
                    }

                    _ -> {
                        self._state = .Error
                    }
                }
            }
            .Success -> {
                self._state = .Error
            }
            .Error -> {
            }
        }
    }
}

KeyParser :: struct {
    mods    : GlfwMod
    typ     : KeyEventType
    _state  : ParserState
}

impl KeyParser {
    new :: (typ: KeyEventType, mods: GlfwMod = GlfwMod.None) -> Rc[Parser] {
        return Rc[Parser].new(KeyParser(
            mods    = mods
            typ     = typ
            _state  = .InProgress
        ))
    }
}

impl Parser for KeyParser {
    state :: (&Self) -> ParserState {
        return self._state
    }

    accepts_numbers :: (&Self) -> bool {
        return false
    }

    build_command :: (&Self) -> Result[Command, String] {
        return Err(fmt.format("No command specified"))
    }

    get_values :: (&Self, chars: &mut Array[Argument]) {
    }

    clone :: (&mut Self) -> Rc[Parser] {
        return Self.new(self.typ, self.mods)
    }

    advance :: (&mut Self, event: KeyEvent) {
        parser_log("KeyParser[{}, {}].advance({})", [self.mods, self.typ, event])

        match self._state {
            .InProgress -> {
                types_match := match self.typ, event.typ {
                    use KeyEventType
                    Char($c1), Char($c2) -> c1 == c2
                    $t1, $t2 -> t1 == t2
                }
                mods_match := self.mods == event.mods
                parser_log("KeyParser[{}, {}].advance({}): types_match={}, mods_match={}", [self.mods, self.typ, event, types_match, mods_match])
                if types_match and mods_match {
                    self._state = .Success
                } else {
                    self._state = .Error
                }
            }

            .Success -> {
                self._state = .Error
            }

            .Error -> {}
        }
    }
}

CommandKind :: enum {
    BuiltIn : String
    Script  : int
}

impl Clone for CommandKind {
    clone :: (&Self) -> CommandKind {
        return match self {
            .BuiltIn($str) -> .BuiltIn(str.clone())
            $arg -> *arg
        }
    }
}

SequenceParser :: struct {
    command : CommandKind
    args    : Array[Argument]

    count   : int

    parsers : Array[Rc[Parser]]
    current : int
    _state  : ParserState
}

impl SequenceParser {
    new :: (command: CommandKind, arguments: []Argument, parsers: []Rc[Parser]) -> Rc[Parser] {
        mut args := Array[Argument].new()
        for arg in arguments {
            args.add(arg.clone())
        }

        mut new_parsers := Array[Rc[Parser]].new(parsers.length)
        for &p in parsers {
            new_parsers.add(p.get().clone())
        }
        return Rc[Parser].new(SequenceParser(
            command = command
            args    = args
            count   = 0
            parsers = new_parsers
            current = 0
            _state  = .InProgress
        ))
    }

    new2 :: (command: CommandKind, args: Array[Argument], parsers: []Rc[Parser]) -> Rc[Parser] {
        mut new_parsers := Array[Rc[Parser]].new(parsers.length)
        for &p in parsers {
            new_parsers.add(p.get().clone())
        }
        return Rc[Parser].new(SequenceParser(
            command = command
            args    = args
            count   = 0
            parsers = new_parsers
            current = 0
            _state  = .InProgress
        ))
    }
}

impl Parser for SequenceParser {
    state :: (&Self) -> ParserState {
        return self._state
    }

    clone :: (&mut Self) -> Rc[Parser] {
        return Self.new2(self.command.clone(), self.args.clone(), self.parsers[..])
    }

    accepts_numbers :: (&Self) -> bool {
        return if current >= 0 and current < self.parsers.count() then self.parsers[current].get().accepts_numbers() else false
    }

    build_command :: (&Self) -> Result[Command, String] {
        if self._state != .Success {
            return Err(fmt.format("Invalid input"))
        }

        for &parser in self.parsers[..] {
            parser.get().get_values(&mut self.args)
        }

        match &self.command {
            .Script($ref) -> {
                return Ok(Command(self.count, .Script(*ref, self.args.clone())))
            }

            .BuiltIn($name) -> {
                command := name.slice()

                if command.starts_with("move.") {
                    name := command[5..]
                    typ := if name == "repeat" {
                        CommandType.RepeatLastMove
                    } else if name == "repeat_inv" {
                        CommandType.RepeatLastMoveInv
                    } else if name == "left" {
                        CommandType.Move(MoveCommand.Left)
                    } else if name == "right" {
                        CommandType.Move(MoveCommand.Right)
                    } else if name == "up" {
                        CommandType.Move(MoveCommand.Up)
                    } else if name == "down" {
                        CommandType.Move(MoveCommand.Down)
                    } else if name == "line_home" {
                        CommandType.Move(MoveCommand.Home)
                    } else if name == "line_end" {
                        CommandType.Move(MoveCommand.End)
                    } else if name == "buffer_home" {
                        CommandType.Move(MoveCommand.BufferHome)
                    } else if name == "buffer_end" {
                        CommandType.Move(MoveCommand.BufferEnd)
                    } else if name == "page_up" {
                        CommandType.Move(MoveCommand.PageUp)
                    } else if name == "page_down" {
                        CommandType.Move(MoveCommand.PageDown)
                    } else if name == "select_left" {
                        CommandType.Move(MoveCommand.SelectLeft)
                    } else if name == "select_right" {
                        CommandType.Move(MoveCommand.SelectRight)
                    } else if name == "select_up" {
                        CommandType.Move(MoveCommand.SelectUp)
                    } else if name == "select_down" {
                        CommandType.Move(MoveCommand.SelectDown)
                    } else if name == "select_line_home" {
                        CommandType.Move(MoveCommand.SelectHome)
                    } else if name == "select_line_end" {
                        CommandType.Move(MoveCommand.SelectEnd)
                    } else if name == "select_buffer_home" {
                        CommandType.Move(MoveCommand.SelectBufferHome)
                    } else if name == "select_buffer_end" {
                        CommandType.Move(MoveCommand.SelectBufferEnd)
                    } else if name == "select_page_up" {
                        CommandType.Move(MoveCommand.SelectPageUp)
                    } else if name == "select_page_down" {
                        CommandType.Move(MoveCommand.SelectPageDown)
                    } else if name == "goto_line_absolute" {
                        CommandType.Move(MoveCommand.GoToLineAbsolute)
                    } else if name == "goto_line_relative_top" {
                        CommandType.Move(MoveCommand.GoToLineRelativeTop)
                    } else if name == "goto_char" {
                        match self.get_argument(0) {
                            .Ok(Argument.Char($ch)) -> CommandType.Move(MoveCommand.GoToChar(ch))
                            .Ok($arg) -> {
                                return Err(fmt.format("[goto_char] Wrong argument type: {}", [&arg]))
                            }
                            .Err($err) -> {
                                return Err(fmt.format("[goto_char] {}", [&err]))
                            }
                        }
                    } else if name == "go_before_char" {
                        match self.get_argument(0) {
                            .Ok(Argument.Char($ch)) -> CommandType.Move(MoveCommand.GoBeforeChar(ch))
                            .Ok($arg) -> {
                                return Err(fmt.format("[go_before_char] Wrong argument type: {}", [&arg]))
                            }
                            .Err($err) -> {
                                return Err(fmt.format("[go_before_char] {}", [&err]))
                            }
                        }
                    } else if name == "goto_char_back" {
                        match self.get_argument(0) {
                            .Ok(Argument.Char($ch)) -> CommandType.Move(MoveCommand.GoToCharBack(ch))
                            .Ok($arg) -> {
                                return Err(fmt.format("[goto_char_back] Wrong argument type: {}", [&arg]))
                            }
                            .Err($err) -> {
                                return Err(fmt.format("[goto_char_back] {}", [&err]))
                            }
                        }
                    } else if name == "go_before_char_back" {
                        match self.get_argument(0) {
                            .Ok(Argument.Char($ch)) -> CommandType.Move(MoveCommand.GoBeforeCharBack(ch))
                            .Ok($arg) -> {
                                return Err(fmt.format("[go_before_char_back] Wrong argument type: {}", [&arg]))
                            }
                            .Err($err) -> {
                                return Err(fmt.format("[go_before_char_back] {}", [&err]))
                            }
                        }
                    } else {
                        return Err(fmt.format("Unknown move command: '{}'", [command]))
                    }

                    return Ok(Command(self.count, typ))
                } else if command.starts_with("editor.") {
                    name := command[7..]

                    typ := if name == "tab_next" {
                        CommandType.TabNext
                    } else if name == "tab_prev" {
                        CommandType.TabPrev
                    } else if name == "mode_insert" {
                        CommandType.SwitchMode(Mode.Insert)
                    } else if name == "mode_normal" {
                        CommandType.SwitchMode(Mode.Normal)
                    } else if name == "mode_command" {
                        CommandType.SwitchMode(Mode.Command)
                    } else if name == "execute_command" {
                        CommandType.ExecuteCommand
                    } else if name == "buffer_save" {
                        CommandType.BufferSave
                    } else {
                        return Err(fmt.format("Unknown editor command: '{}'", [command]))
                    }

                    return Ok(Command(self.count, typ))
                } else if command.starts_with("buffer.") {
                    name := command[7..]

                    typ := if name == "delete_line" {
                        CommandType.DeleteLine
                    } else if name == "delete_left" {
                        CommandType.DeleteLeft
                    } else if name == "delete_right" {
                        CommandType.DeleteRight
                    } else if name == "insert_tab" {
                        CommandType.Edit(EditCommand.InsertTab)
                    } else if name == "indent_line" {
                        CommandType.Edit(EditCommand.IndentLine)
                    } else if name == "deindent_line" {
                        CommandType.Edit(EditCommand.DeindentLine)
                    } else if name == "undo" {
                        CommandType.Edit(EditCommand.Undo)
                    } else if name == "redo" {
                        CommandType.Edit(EditCommand.Redo)
                    } else if name == "copy" {
                        CommandType.Edit(EditCommand.Copy)
                    } else if name == "paste" {
                        CommandType.Edit(EditCommand.Paste)
                    } else if name == "insert_char" {
                        match self.get_argument(0) {
                            .Ok(Argument.Char($ch)) -> CommandType.Edit(EditCommand.InsertChar(ch))
                            .Ok($arg) -> {
                                return Err(fmt.format("[insert_char] Wrong argument type: {}", [&arg]))
                            }
                            .Err($err) -> {
                                return Err(fmt.format("[insert_char] {}", [&err]))
                            }
                        }
                    } else if name == "insert" {
                        match self.get_argument(0) {
                            .Ok(Argument.Str($str)) -> CommandType.Edit(EditCommand.InsertText(str))
                            .Ok($arg) -> {
                                return Err(fmt.format("[insert] Wrong argument type: {}", [&arg]))
                            }
                            .Err($err) -> {
                                return Err(fmt.format("[insert] {}", [&err]))
                            }
                        }
                    } else {
                        return Err(fmt.format("Unknown view command: '{}'", [command]))
                    }

                    return Ok(Command(self.count, typ))

                } else if command.starts_with("view.") {
                    name := command[5..]

                    typ := if name == "add_cursor_above" {
                        CommandType.View(ViewCommand.AddCursorAbove)
                    } else if name == "add_cursor_below" {
                        CommandType.View(ViewCommand.AddCursorBelow)
                    } else {
                        return Err(fmt.format("Unknown view command: '{}'", [command]))
                    }

                    return Ok(Command(self.count, typ))
                } else {
                    return Err(fmt.format("Unknown command: '{}'", [command]))
                }
            }

            _ -> @assert(false)
        }
        @assert(false)
        return Err(fmt.format(""))
    }

    get_argument :: (&Self, index: int) -> Result[Argument, String] {
        if index < 0 or index >= self.args.count() {
            return Err(fmt.format("No argument at index {}", [index]))
        }

        return Ok(self.args[index].clone())
    }

    get_values :: (&Self, chars: &mut Array[Argument]) {
    }

    advance :: (&mut Self, event: KeyEvent) {
        parser_log("SequenceParser[{}].advance({})", [self.current, event])

        match self._state {
            .InProgress -> {
                if self.current == 0 and event.mods == .None and !self.parsers[0].get().accepts_numbers() {
                    match event.typ {
                        .Char($ch) if ch.is_digit() -> {
                            self.count = self.count * 10 + int(ch - '0')
                            return
                        }
                        _ -> {}
                    }
                }

                if self.current >= self.parsers.count() {
                    self._state = .Error
                } else {
                    current := self.parsers[self.current].clone()
                    current.get().advance(event)

                    match current.get().state() {
                        .InProgress -> {
                            self._state = .InProgress
                        }

                        .Success -> {
                            self.current += 1
                            if self.current == self.parsers.count() {
                                self._state = .Success
                            }
                        }

                        .Error -> {
                            self._state = .Error
                        }
                    }
                }
            }

            .Success -> {
                self._state = .Error
            }

            .Error -> {}
        }
    }
}

NormalParser :: struct {
    normal_parsers  : Array[Rc[Parser]]
    move_parsers    : Array[Rc[Parser]]
    final_parser    : Option[Rc[Parser]]
    _state          : ParserState
}

impl NormalParser {
    new :: (normal_parsers: []Rc[Parser], move_parsers: []Rc[Parser]) -> Rc[Parser] {
        mut new_normal_parsers := Array[Rc[Parser]].new(normal_parsers.length)
        for &p in normal_parsers {
            new_normal_parsers.add(p.get().clone())
        }

        mut new_move_parsers := Array[Rc[Parser]].new(move_parsers.length)
        for &p in move_parsers {
            new_move_parsers.add(p.get().clone())
        }
        return Rc[Parser].new(NormalParser(
            normal_parsers  = new_normal_parsers
            move_parsers    = new_move_parsers
            final_parser    = .None
            _state          = .InProgress
        ))
    }
}

impl Parser for NormalParser {
    state :: (&Self) -> ParserState {
        return self._state
    }

    accepts_numbers :: (&Self) -> bool {
        for &parser in self.normal_parsers[..] {
            if parser.get().accepts_numbers() then {
                return true
            }
        }
        for &parser in self.move_parsers[..] {
            if parser.get().accepts_numbers() then {
                return true
            }
        }

        return false
    }

    clone :: (&mut Self) -> Rc[Parser] {
        return Self.new(self.normal_parsers[..], self.move_parsers[..])
    }

    build_command :: (&Self) -> Result[Command, String] {
        if self._state != .Success {
            return Err(fmt.format("{} sequences matched the input", [self.normal_parsers.count()]))
        }

        @assert(self.final_parser.is_some())

        return self.final_parser.unwrap_ref().get().build_command()
    }

    get_values :: (&Self, chars: &mut Array[Argument]) {
    }

    advance :: (&mut Self, event: KeyEvent) {
        match self._state {
            .InProgress -> {
                parser_log("NormalParser.advance({})", [event])

                normal_success_parsers      := Array[Rc[Parser]].new()
                normal_in_progress_parsers  := Array[Rc[Parser]].new()
                move_success_parsers        := Array[Rc[Parser]].new()
                move_in_progress_parsers    := Array[Rc[Parser]].new()

                for &p in self.normal_parsers[..] {
                    p.get().advance(event)
                    match p.get().state() {
                        .InProgress -> {
                            normal_in_progress_parsers.add(p.clone())
                        }
                        .Success -> {
                            normal_success_parsers.add(p.clone())
                        }
                        .Error -> {}
                    }
                }

                for &p in self.move_parsers[..] {
                    p.get().advance(event)
                    match p.get().state() {
                        .InProgress -> {
                            move_in_progress_parsers.add(p.clone())
                        }
                        .Success -> {
                            move_success_parsers.add(p.clone())
                        }
                        .Error -> {}
                    }
                }

                parser_log("NormalParser.advance({}): {} success, {} in progress", [event, normal_success_parsers.count(), normal_in_progress_parsers.count()])

                if normal_success_parsers.count() == 1 {
                    self._state = .Success
                    self.final_parser = Some(normal_success_parsers[0].clone())
                    Memory.drop(normal_success_parsers)
                    Memory.drop(normal_in_progress_parsers)
                    Memory.drop(move_success_parsers)
                    Memory.drop(move_in_progress_parsers)
                } else if normal_success_parsers.count() > 0 {
                    self._state = .Error
                    self.normal_parsers = normal_success_parsers
                    Memory.drop(normal_in_progress_parsers)
                    Memory.drop(move_success_parsers)
                    Memory.drop(move_in_progress_parsers)
                } else if normal_in_progress_parsers.count() > 0 {
                    self._state = .InProgress
                    self.normal_parsers = normal_in_progress_parsers
                    Memory.drop(normal_success_parsers)
                    Memory.drop(move_success_parsers)
                    Memory.drop(move_in_progress_parsers)
                } else if move_success_parsers.count() == 1 {
                    self._state = .Success
                    self.final_parser = Some(move_success_parsers[0].clone())
                    Memory.drop(normal_success_parsers)
                    Memory.drop(normal_in_progress_parsers)
                    Memory.drop(move_success_parsers)
                    Memory.drop(move_in_progress_parsers)
                } else if move_success_parsers.count() > 1 {
                    self._state = .Error
                    self.normal_parsers.clear()
                    self.move_parsers = move_success_parsers
                    Memory.drop(normal_success_parsers)
                    Memory.drop(normal_in_progress_parsers)
                    Memory.drop(move_in_progress_parsers)
                } else if move_in_progress_parsers.count() > 0 {
                    self._state = .InProgress
                    self.normal_parsers.clear()
                    self.move_parsers = move_in_progress_parsers
                    Memory.drop(normal_success_parsers)
                    Memory.drop(normal_in_progress_parsers)
                    Memory.drop(move_success_parsers)
                } else {
                    self._state = .Error
                    Memory.drop(normal_success_parsers)
                    Memory.drop(normal_in_progress_parsers)
                    Memory.drop(move_success_parsers)
                    Memory.drop(move_in_progress_parsers)
                }
            }

            .Success -> {
                self._state = .Error
            }

            .Error -> {}
        }
    }
}

impl Chim {
    key_input_parser :: (self: ^Chim) {
    }

    parse :: (&mut Self, mut event_index: int) {
    }

    handle_key_event :: (&mut Self, event: KeyEvent) {
        // io.formatln("===========================")
        // io.formatln("{}", [&event])

        self.key_events.add(event)

        if self.current_parser.is_none() {
            parser_log("handle_key_event: creating new parser")

            match self.parsers.get(current_mode) {
                Some($parsers) -> {
                    self.current_parser = Some(NormalParser.new(parsers.normal[..], parsers.move[..]))
                }

                None -> {
                    @assert(false)
                }
            }
        }

        @assert(self.current_parser.is_some())

        parser := self.current_parser.unwrap_ref().clone()
        parser.get().advance(event)
        match parser.get().state() {
            .InProgress -> parser_log("handle_key_event: parser still in progress")
            .Success -> {
                parser_log("handle_key_event: parser succeeded")
                command := parser.get().build_command()
                // io.formatln("command: {}", [&command])

                match command {
                    Ok($command) -> {
                        self.commands.push(command)
                    }
                    Err($err) -> {
                        io.formatln("Failed to build command for input: {}", [err.slice()])
                    }
                }

                self.current_parser = .None
                self.key_events.clear()
            }
            .Error -> {
                parser_log("handle_key_event: parser failed")
                self.current_parser = .None
                self.key_events.clear()
            }
        }
    }

    on_key :: (&mut Self, key: GlfwKey, scancode: i32, action: GlfwAction, mods: GlfwMod) {
        // io.formatln("{}, {}, {}, {}", [key, scancode, action, mods])
        match action, key {
            use GlfwKey
            use GlfwAction
            use GlfwMod

            Press, LeftShift        -> { current_mods_l = current_mods_l or Shift }
            Release, LeftShift      -> { current_mods_l = current_mods_l and !Shift }
            Press, RightShift       -> { current_mods_r = current_mods_r or Shift }
            Release, RightShift     -> { current_mods_r = current_mods_r and !Shift }

            Press, LeftControl      -> { current_mods_l = current_mods_l or Control }
            Release, LeftControl    -> { current_mods_l = current_mods_l and !Control }
            Press, RightControl     -> { current_mods_r = current_mods_r or Control }
            Release, RightControl   -> { current_mods_r = current_mods_r and !Control }

            Press, LeftAlt          -> { current_mods_l = current_mods_l or Alt }
            Release, LeftAlt        -> { current_mods_l = current_mods_l and !Alt }
            Press, RightAlt         -> { current_mods_r = current_mods_r or (Alt or Control) }
            Release, RightAlt       -> { current_mods_r = current_mods_r and !(Alt or Control) }

            Press, LeftSuper        -> { current_mods_l = current_mods_l or Super }
            Release, LeftSuper      -> { current_mods_l = current_mods_l and !Super }
            Press, RightSuper       -> { current_mods_r = current_mods_r or Super }
            Release, RightSuper     -> { current_mods_r = current_mods_r and !Super }

            Press, F1               -> {
                self.show_debug_window = !self.show_debug_window
                return
            }

            Press, F2               -> {
                self.show_demo_window = !self.show_demo_window
                return
            }

            _ -> {}
        }

        current_mods = current_mods_l or current_mods_r

        if !self.has_focus {
            return
        }

        if action == .Press or action == .Repeat {
            if mods != .None and mods != .Shift {
                key_name_c := glfwGetKeyName(key, scancode)
                if key_name_c != null {
                    key_name := string.from_cstring(key_name_c)
                    ch, _ := Utf8.decode(key_name.bytes)
                    if ch == 'e' and (GlfwMod.Control or GlfwMod.Alt is in mods) {
                        self.handle_key_event(KeyEvent(mods and !(GlfwMod.Control or GlfwMod.Alt), KeyEventType.Char('€')))
                        return
                    }
                    if ch == 'q' and (GlfwMod.Control or GlfwMod.Alt is in mods) {
                        self.handle_key_event(KeyEvent(mods and !(GlfwMod.Control or GlfwMod.Alt), KeyEventType.Char('@')))
                        return
                    }
                    if ch.is_alpha() {
                        self.handle_key_event(KeyEvent(mods, KeyEventType.Char(ch)))
                        return
                    }
                }
            }

            mut mods := self.current_mods
            typ := match key {
                GlfwKey._0 if mods == .Control -> KeyEventType.Char('0')
                GlfwKey._1 if mods == .Control -> KeyEventType.Char('1')
                GlfwKey._2 if mods == .Control -> KeyEventType.Char('2')
                GlfwKey._3 if mods == .Control -> KeyEventType.Char('3')
                GlfwKey._4 if mods == .Control -> KeyEventType.Char('4')
                GlfwKey._5 if mods == .Control -> KeyEventType.Char('5')
                GlfwKey._6 if mods == .Control -> KeyEventType.Char('6')
                GlfwKey._7 if mods == .Control -> KeyEventType.Char('7')
                GlfwKey._8 if mods == .Control -> KeyEventType.Char('8')
                GlfwKey._9 if mods == .Control -> KeyEventType.Char('9')

                GlfwKey.Space if self.current_mods != .None -> KeyEventType.Space
                GlfwKey.Escape -> KeyEventType.Escape
                GlfwKey.Enter -> KeyEventType.Enter
                GlfwKey.Tab -> KeyEventType.Tab
                GlfwKey.Backspace -> KeyEventType.Backspace
                GlfwKey.Insert -> KeyEventType.Insert
                GlfwKey.Delete -> KeyEventType.Delete
                GlfwKey.Right -> KeyEventType.Right
                GlfwKey.Left -> KeyEventType.Left
                GlfwKey.Down -> KeyEventType.Down
                GlfwKey.Up -> KeyEventType.Up
                GlfwKey.PageUp -> KeyEventType.PageUp
                GlfwKey.PageDown -> KeyEventType.PageDown
                GlfwKey.Home -> KeyEventType.Home
                GlfwKey.End -> KeyEventType.End
                GlfwKey.CapsLock -> KeyEventType.CapsLock
                GlfwKey.ScrollLock -> KeyEventType.ScrollLock
                GlfwKey.NumLock -> KeyEventType.NumLock
                GlfwKey.PrintScreen -> KeyEventType.PrintScreen
                GlfwKey.Pause -> KeyEventType.Pause
                GlfwKey.F1 -> KeyEventType.F1
                GlfwKey.F2 -> KeyEventType.F2
                GlfwKey.F3 -> KeyEventType.F3
                GlfwKey.F4 -> KeyEventType.F4
                GlfwKey.F5 -> KeyEventType.F5
                GlfwKey.F6 -> KeyEventType.F6
                GlfwKey.F7 -> KeyEventType.F7
                GlfwKey.F8 -> KeyEventType.F8
                GlfwKey.F9 -> KeyEventType.F9
                GlfwKey.F10 -> KeyEventType.F10
                GlfwKey.F11 -> KeyEventType.F11
                GlfwKey.F12 -> KeyEventType.F12
                GlfwKey.F13 -> KeyEventType.F13
                GlfwKey.F14 -> KeyEventType.F14
                GlfwKey.F15 -> KeyEventType.F15
                GlfwKey.F16 -> KeyEventType.F16
                GlfwKey.F17 -> KeyEventType.F17
                GlfwKey.F18 -> KeyEventType.F18
                GlfwKey.F19 -> KeyEventType.F19
                GlfwKey.F20 -> KeyEventType.F20
                GlfwKey.F21 -> KeyEventType.F21
                GlfwKey.F22 -> KeyEventType.F22
                GlfwKey.F23 -> KeyEventType.F23
                GlfwKey.F24 -> KeyEventType.F24
                GlfwKey.F25 -> KeyEventType.F25
                GlfwKey.Kp0 -> KeyEventType.Kp0
                GlfwKey.Kp1 -> KeyEventType.Kp1
                GlfwKey.Kp2 -> KeyEventType.Kp2
                GlfwKey.Kp3 -> KeyEventType.Kp3
                GlfwKey.Kp4 -> KeyEventType.Kp4
                GlfwKey.Kp5 -> KeyEventType.Kp5
                GlfwKey.Kp6 -> KeyEventType.Kp6
                GlfwKey.Kp7 -> KeyEventType.Kp7
                GlfwKey.Kp8 -> KeyEventType.Kp8
                GlfwKey.Kp9 -> KeyEventType.Kp9
                GlfwKey.KpDecimal -> KeyEventType.KpDecimal
                GlfwKey.KpDivide -> KeyEventType.KpDivide
                GlfwKey.KpMultiply -> KeyEventType.KpMultiply
                GlfwKey.KpSubtract -> KeyEventType.KpSubtract
                GlfwKey.KpAdd -> KeyEventType.KpAdd
                GlfwKey.KpEnter -> KeyEventType.KpEnter
                GlfwKey.KpEqual -> KeyEventType.KpEqual

                _ -> {
                    // io.formatln("                                                              ignoring key {}, {}, {}", [key, action, mods])
                    return
                }
            }

            self.handle_key_event(KeyEvent(mods, typ))
        }
    }

    on_char :: (&mut Self, c: char) {
        if !self.has_focus {
            return
        }

        if c == '@' or c == '€' or (c == ' ' and self.current_mods != .None) {
            return
        }

        if c == ' ' {
            self.handle_key_event(KeyEvent(self.current_mods, KeyEventType.Space))
            return
        }

        mods, c := if c.is_alpha() or c.is_digit() {
            if (c >= 'A' and c <= 'Z') or (c == 'Ä' or c == 'Ö' or c == 'Ü') {
                self.current_mods or GlfwMod.Shift, c.to_lower()
            } else {
                self.current_mods, c
            }
        } else {
            GlfwMod.None, c
        }

        self.handle_key_event(KeyEvent(mods, KeyEventType.Char(c)))
    }
}

parser_log :: (format: string, args: []^any = []) {
    if const debug_parser {
        io.formatln(format, args)
    }
}