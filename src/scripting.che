use import std.array
use import std.rc
use import std.string

io  :: import std.io
fmt :: import std.fmt

use import lua
lua :: import lua_cheez

use import chim
use import editor
use import gap_buffer
use import editor_input
use import editor_render
use import clipboard
use import commands

#export_scope

UserData :: enum {
    None
    UDBuffer    : Rc[Buffer]
    UDView      : Rc[View]
    UDTab       : Rc[Tab]
}
BUFFER_METATABLE    :: "__metatable_buffer"
VIEW_METATABLE      :: "__metatable_view"
TAB_METATABLE       :: "__metatable_tab"

ScriptingEngine :: struct {
    state : lua.State
}

impl ScriptingEngine {
    new :: () -> Result[Rc[ScriptingEngine], String] {
        mut state := try_with(lua.State.new(), {
            return Err(fmt.format("Failed to create lua state: {}", [err]))
        })

        state.open_libs()

        // create buffer metatable
        state.create_table(nrec = 5)
        state.push_function(user_data_index)
        state.set_field(-2, "__index")
        // state.push_function(buffer_index)
        // state.set_field(-2, "__custom_index")
        // state.push_function(drop_buffer)
        // state.set_field(-2, "__gc")
        // state.push_function(buffer_insert)
        // state.set_field(-2, "insert")
        state.set_global(BUFFER_METATABLE)

        return Ok(Rc[ScriptingEngine].new(ScriptingEngine(
            state   = state
        )))
    }

    load_file :: (&mut Self, path: string) -> Result[(), String] {
        try(self.state.do_file(path))
        return Ok()
    }
}


/// args: self, key
user_data_index :: (state: &mut lua.State) -> Result[int, String] {
    arg_count := state.get_top()
    if arg_count != 2 {
        return Err(fmt.format("[user_data_index] only accepts exactly 2 arguments"))
    }

    user_data := cast(^mut UserData) try_with(state.to_user_data(1), {
        return Err(fmt.format("[user_data_index] not a userdata"))
    })

    // push metatable of user data at index 3
    if !state.get_metatable(1) {
        return Err(fmt.format("[user_data_index] no key found"))
    }
    // push key
    state.push_value(2)
    typ := lua.Type(lua_rawget(state.state, 3))
    return match typ {
        .Nil -> match state.get_field(3, "__custom_index") {
            .Nil -> Err(fmt.format("[user_data_index] no key found"))
            $typ -> {
                state.push_value(1)
                state.push_value(2)
                try(state.call(2))
                Ok(1)
            }
        }
        _ -> Ok(1)
    }
}

// drop_buffer :: (state: &mut lua.State) -> Result[int, String] {
//     user_data := cast(^mut UserData) try_with(state.to_user_data(-1), {
//         return Err(fmt.format("[drop_buffer] not a userdata"))
//     })

//     return match &*user_data {
//         .Buff($buffer) -> {
//             buffer.drop()
//             *user_data = UserData.None
//             Ok(0)
//         }

//         _ -> Err(fmt.format("[drop_buffer] not a buffer"))
//     }
// }

// new_buffer :: (state: &mut lua.State) -> Result[int, String] {
//     name := try_with(state.to_string(-1), {
//         return Err(fmt.format("[new_buffer] Argument must be a string"))
//     })

//     mem := cast(^mut UserData) state.new_user_data_uv(@sizeof(UserData), 0)
//     *mem = UserData.Buff(Rc[Buffer].new(Buffer(name.to_owned())))

//     // set metatable
//     state.get_global(BUFFER_METATABLE)
//     state.set_metatable(-2)

//     return Ok(1)
// }

// buffer_index :: (state: &mut lua.State) -> Result[int, String] {
//     arg_count := state.get_top()
//     if arg_count != 2 {
//         return Err(fmt.format("[buffer_index] only accepts exactly 1 arguments"))
//     }

//     user_data := cast(^mut UserData) try_with(state.to_user_data(1), {
//         return Err(fmt.format("[buffer_index] not a userdata"))
//     })

//     return match &*user_data {
//         .Buff($buffer) -> match state.to_int(2) {
//             Ok($value) -> {
//                 if value == 0 {
//                     state.push_nil()
//                     return Ok(1)
//                     // return Err(fmt.format("[buffer_index] index 0 is out of range"))
//                 }
//                 name := buffer.get().name.slice()
//                 index := int.clamp(if value < 0 {
//                     name.bytes.length + value + 1
//                 } else {
//                     value
//                 }, 1, name.bytes.length)
//                 state.push_string(name[(index - 1) .. index])
//                 Ok(1)
//             }
//             Err($err) -> Err(fmt.format("[buffer_index] index must be an int: {}", [&err]))
//         }

//         $value -> Err(fmt.format("[buffer_index] not a buffer: {}", [value]))
//     }
// }

// buffer_insert :: (state: &mut lua.State) -> Result[int, String] {
//     arg_count := state.get_top()
//     if arg_count != 4 {
//         return Err(fmt.format("[buffer_insert] only accepts exactly 3(4) arguments"))
//     }

//     user_data := cast(^mut UserData) try_with(state.to_user_data(1), {
//         return Err(fmt.format("[buffer_insert] not a userdata"))
//     })

//     return match &*user_data {
//         .Buff($buffer) -> {
//             line := state.to_int(2).unwrap()
//             column := state.to_int(3).unwrap()
//             text := state.to_string(4).unwrap()
//             buffer.get_mut().insert(line, column, text)
//             Ok(0)
//         }

//         $value -> Err(fmt.format("[buffer_insert] not a buffer: {}", [value]))
//     }
// }