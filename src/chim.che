use import std.rc
use import std.box
use import std.string
use import std.array
use import std.ring_queue
use import std.unicode

mem :: import std.mem.allocator
io  :: import std.io
fmt :: import std.fmt
C   :: import std.c

use import glfw
use import glfw_hl

use import imgui_hl
use import imgui_opengl
imgui :: import imgui

use import editor
use import gap_buffer

vec2 :: imgui.ImVec2
vec4 :: imgui.ImVec4

vec2_zero : vec2 = vec2(0, 0)
vec4_zero : vec4 = vec4(0, 0, 0, 0)

#export_scope

SLOTS_X :: 2048
SLOTS_Y :: 2048

Slot :: struct {
    c   : char
    fg  : PaletteIndex
    bg  : PaletteIndex
    col : int = 0
}

PaletteIndex :: enum #tag_type(i32) #copy {
    Default
    Keyword
    Number
    String
    CharLiteral
    Punctuation
    Preprocessor
    Identifier
    KnownIdentifier
    PreprocIdentifier
    Comment
    MultiLineComment
    Background
    HighlightedBackground
    MenuBackground
    Cursor
    Selection
    ErrorMarker
    Breakpoint
    LineNumber
    CurrentLineFill
    CurrentLineFillInactive
    CurrentLineEdge
    Whitespace
    Max
}

Command :: enum {
    ChangeFontSize  : f32
    ChangeFont      : String
    TabNext
    TabPrev
}

Palette :: struct {
    values : [int(PaletteIndex.Max)]u32
}

impl Palette {
    dark :: () -> Palette {
        mut values : [int(PaletteIndex.Max)]u32 = default
        *values[int(PaletteIndex.Default)]                      = 0xffbfbfbf
        *values[int(PaletteIndex.Keyword)]                      = 0xffd69c56
        *values[int(PaletteIndex.Number)]                       = 0xff00ff00
        *values[int(PaletteIndex.String)]                       = 0xff7070e0
        *values[int(PaletteIndex.CharLiteral)]                  = 0xff70a0e0
        *values[int(PaletteIndex.Punctuation)]                  = 0xffffffff
        *values[int(PaletteIndex.Preprocessor)]                 = 0xff408080
        *values[int(PaletteIndex.Identifier)]                   = 0xffaaaaaa
        *values[int(PaletteIndex.KnownIdentifier)]              = 0xff9bc64d
        *values[int(PaletteIndex.PreprocIdentifier)]            = 0xffc040a0
        *values[int(PaletteIndex.Comment)]                      = 0xff206020
        *values[int(PaletteIndex.MultiLineComment)]             = 0xff406020
        *values[int(PaletteIndex.Background)]                   = 0xff101010
        *values[int(PaletteIndex.HighlightedBackground)]        = 0xff171717
        *values[int(PaletteIndex.MenuBackground)]               = 0xff202020
        *values[int(PaletteIndex.Cursor)]                       = 0xffe0e0e0
        *values[int(PaletteIndex.Selection)]                    = 0x80a06020
        *values[int(PaletteIndex.ErrorMarker)]                  = 0x800020ff
        *values[int(PaletteIndex.Breakpoint)]                   = 0x40f08000
        *values[int(PaletteIndex.LineNumber)]                   = 0xff707000
        *values[int(PaletteIndex.CurrentLineFill)]              = 0x40000000
        *values[int(PaletteIndex.CurrentLineFillInactive)]      = 0x40808080
        *values[int(PaletteIndex.CurrentLineEdge)]              = 0x40a0a0a0
        *values[int(PaletteIndex.Whitespace)]                   = 0xff202020
        return Palette(values)
    }

    get :: (&Self, index: PaletteIndex) -> u32 {
        return *self.values[int(index)]
    }
}

Mode :: enum #copy {
    Normal
    Insert
    Visual
}

CursorType :: enum #copy {
    Line
    Full
    Underscore
}



Chim :: struct {
    slots           : []mut Slot

    cursors         := Array[(col: int, row: int, typ: CursorType)].new()
    commands        := RingQueue[Command].new()

    // editor stuff
    current_mode    := Mode.Normal
    recording_macro := false

    tabs            := Array[Rc[Tab]].new()
    buffers         := Array[Rc[Buffer]].new()

    current_buffer  := Rc[Buffer].empty()

    active_tab      := 0

    window_pixel_size := vec2(0, 0)
    has_focus       := false

    // settings
    wrapping_enabled    := true
    highlight_curr_line := true
    line_number_mode    := LineNumberMode.RelativeCursor
    show_whitespace     := true
    tab_width           := 4

    // modifiers, keys, etc.
    current_mods_l  := GlfwMod.None
    current_mods_r  := GlfwMod.None
    current_mods    := GlfwMod.None

    // font stuff
    current_font    := String.empty()
    font_size       := 16.0f
    character_size  := vec2(21, 16)

    // theme stuff
    palette         := Palette.dark()

    // debug stuff
    vsync               := true
    show_debug_window   := false
    show_demo_window    := false
}

impl Drop for Chim {
    drop :: (&Self) {
        mem.free_n(self.slots)
    }
}

impl Chim {
    new :: () -> Chim {
        slots := mem.alloc_n(Slot, SLOTS_X * SLOTS_Y)
        C.memset(cast slots.data, 0, cast @sizeof(Slot) * slots.length)
        return Chim(
            slots = slots
        )
    }

    on_framebuffer_resize :: (&mut Self, width: f32, height: f32) {
        self.window_pixel_size = vec2(width, height)
    }

    on_focus :: (&mut Self, focused: i32) {
        if focused == 0 {
            current_mods_l = .None
            current_mods_r = .None
            current_mods = current_mods_l or current_mods_r
        }
    }

    on_iconify :: (&mut Self, iconified: i32) {
        if iconified != 0 {
            current_mods_l = .None
            current_mods_r = .None
            current_mods = current_mods_l or current_mods_r
        }
    }

    initialize :: (&mut Self, args: []String) {
        for row in 0 .. SLOTS_X {
            for col in 0 .. SLOTS_Y {
                *self.slots[col + row * SLOTS_X] = Slot('Â´', .Comment, .Background)
            }
        }

        self.set_font("FiraMono-Regular.ttf")
        self.set_font_size(18.5f)

        if args.length > 0 {
            for &file in args {
                match Buffer.from_file(file.slice()) {
                    Ok($buffer) -> {
                        self.buffers.add(buffer.clone())
                        tabs.add(Tab.new(View.new(buffer)))
                    }
                    Err() -> {
                        io.formatln("[ERROR] Failed to load file '{}'", [file.slice()])
                    }
                }
            }
        }

        if self.buffers.count() == 0 {
            self.current_buffer = Buffer.scratch()
            self.buffers.add(self.current_buffer.clone())
            tabs.add(Tab.new(View.new(self.current_buffer.clone())))
        } else {
            self.current_buffer = self.buffers[0].clone()
        }
    }

    get_window_dim :: (&Self) -> (cols: int, rows: int) {
        rows := int(self.window_pixel_size.y / self.character_size.y)

        mut scale := self.character_size.x * (self.window_pixel_size.y / (self.character_size.y * f32(rows)))

        return int(self.window_pixel_size.x / scale), rows
    }

    set_font :: (&mut Self, path: string) {
        self.commands.push(.ChangeFont(path.to_owned()))
    }

    set_font_size :: (&mut Self, size: f32) {
        self.commands.push(.ChangeFontSize(size))
    }

    update :: (&mut Self) {
        mut font_changed := false
        mut rerender := false

        while self.commands.count() > 0 {
            match self.commands.pop() {
                .ChangeFontSize($size) -> {
                    if size >= 10 {
                        self.font_size = size
                        font_changed = true
                    }
                }

                .ChangeFont($path) -> {
                    self.current_font.clear()
                    fmt.format_into(&mut self.current_font, "fonts/{}", [path])
                    font_changed = true
                }

                .TabNext -> {
                    self.active_tab = (self.active_tab + 1) % self.tabs.count()
                }

                .TabPrev -> {
                    self.active_tab = (self.active_tab - 1 + self.tabs.count()) % self.tabs.count()
                }
            }
        }

        if font_changed {
            iio := imgui.GetIO()
            iio.Fonts.Clear()
            font := iio.Fonts.AddFontFromFileTTF(self.current_font.as_cstring(), self.font_size, null, null)
            iio.Fonts.Build()
            ImGui_ImplOpenGL3_DestroyFontsTexture()
            ImGui_ImplOpenGL3_CreateFontsTexture()
            self.character_size = font.CalcTextSizeA(self.font_size, f32.max, -1, "#", null, null)
        }

        self.active_tab = self.active_tab.clamp(0, self.tabs.count() - 1)


        // @temp
        rerender = true

        if rerender {
            cols, rows := self.get_window_dim()

            // clear right-most column
            for r in 0 .. rows {
                *self.slots[cols + r * SLOTS_X] = Slot('`0', .Default, .Background)
            }

            self.render_tab_bar(0)

            self.render_tab(self.tabs[self.active_tab].get(), (0, 1), (cols, rows - 2))

            self.render_status_line(rows - 2)
            self.render_command_line(rows - 1)
        }
    }
}