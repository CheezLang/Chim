use import std.rc
use import std.box
use import std.string
use import std.array
use import std.ring_queue
use import std.unicode
use import std.fiber
use import std.mem.std_heap_allocator

mem :: import std.mem.allocator
io  :: import std.io
fmt :: import std.fmt
C   :: import std.c

use import glfw
use import glfw_hl

use import imgui_hl
use import imgui_opengl
imgui :: import imgui

use import editor
use import gap_buffer
use import editor_input
use import editor_render

vec2 :: imgui.ImVec2
vec4 :: imgui.ImVec4

vec2_zero : vec2 = vec2(0, 0)
vec4_zero : vec4 = vec4(0, 0, 0, 0)

#export_scope

SLOTS_X :: 2048
SLOTS_Y :: 2048

Slot :: struct {
    c   : char
    fg  : PaletteIndex
    bg  : PaletteIndex
    col : int = 0
}

Command :: enum {
    ChangeFontSize  : f32
    ChangeFont      : String
    TabNext
    TabPrev
}

Mode :: enum #copy {
    Normal
    Insert
    Visual
}

CursorType :: enum #copy {
    Line
    Full
    Underscore
}

// <move>   `Left`       -> view.move_cursor_left
// <normal> i            -> editor.enter_insert_mode
// <move>   i{c: char}   -> view.move_inside c
// <normal> f{c: char}   -> view.move_cursor_to c
// <normal> d{m: mov}    -> view.delete_moved_range m
// <normal> gd{c: char}{m: mov} -> view.delete_all_occurances_of c m

// gdx{Left}    -> view.delete_all_occurances_of 'x' view.move_cursor_left
// gdyfl        -> view.delete_all_occurances_of 'y' (view.move_cursor_to 'l')


CommandStep :: enum #copy {
    Key     : KeyEvent
    Move    : char
}

CommandParser :: struct {
    command : String
    steps   : Array[CommandStep]
}

impl CommandParser {
    from_slice :: (command: string, steps: []CommandStep) -> CommandParser {
        return CommandParser(command.to_owned(), Array[CommandStep].from_slice(steps))
    }

    parse :: (text: string) -> Result[CommandParser, ()] {
        return Err()
    }
}

Chim :: struct {
    slots           : []mut Slot

    cursors         := Array[(col: int, row: int, typ: CursorType)].new()
    commands        := RingQueue[Command].new()

    parser_fiber    : ^Fiber = null
    key_events      := GapBuffer[KeyEvent].new(20, &DEFAULT_STD_HEAP_ALLOCATOR)
    command_parsers := Array[Rc[CommandParser]].new()
    active_parsers  := Array[Rc[CommandParser]].new()

    // editor stuff
    current_mode    := Mode.Normal
    recording_macro := false

    tabs            := Array[Rc[Tab]].new()
    active_tab      := 0
    buffers         := Array[Rc[Buffer]].new()
    current_buffer  := Rc[Buffer].empty()

    window_pixel_size   := vec2(0, 0)
    has_focus           := false

    // settings
    wrapping_enabled    := true
    highlight_curr_line := true
    line_number_mode    := LineNumberMode.RelativeCursor
    show_whitespace     := true
    tab_width           := 4

    // modifiers, keys, etc.
    current_mods_l  := GlfwMod.None
    current_mods_r  := GlfwMod.None
    current_mods    := GlfwMod.None

    // font stuff
    current_font    := String.empty()
    font_size       := 16.0f
    character_size  := vec2(21, 16)

    // theme stuff
    palette         := Palette.dark()

    // debug stuff
    vsync               := true
    show_debug_window   := false
    show_demo_window    := false
}

impl Drop for Chim {
    drop :: (&Self) {
        mem.free_n(self.slots)
    }
}

impl Chim {
    new :: () -> Chim {
        slots := mem.alloc_n(Slot, SLOTS_X * SLOTS_Y)
        C.memset(cast slots.data, 0, cast @sizeof(Slot) * slots.length)
        return Chim(
            slots = slots
        )
    }

    on_framebuffer_resize :: (&mut Self, width: f32, height: f32) {
        self.window_pixel_size = vec2(width, height)
    }

    on_focus :: (&mut Self, focused: i32) {
        if focused == 0 {
            current_mods_l = .None
            current_mods_r = .None
            current_mods = current_mods_l or current_mods_r
        }
    }

    on_iconify :: (&mut Self, iconified: i32) {
        if iconified != 0 {
            current_mods_l = .None
            current_mods_r = .None
            current_mods = current_mods_l or current_mods_r
        }
    }

    initialize :: (&mut Self, args: []String) {
        self.parser_fiber = Fiber.new(cast(Fn(^Chim)) Chim.key_input_parser, ^*self)

        for row in 0 .. SLOTS_X {
            for col in 0 .. SLOTS_Y {
                *self.slots[col + row * SLOTS_X] = Slot('Â´', .Comment, .Background)
            }
        }

        self.set_font("FiraMono-Regular.ttf")
        self.set_font_size(18.5f)

        if args.length > 0 {
            for &file in args {
                match Buffer.from_file(file.slice()) {
                    Ok($buffer) -> {
                        self.buffers.add(buffer.clone())
                        tabs.add(Tab.new(View.new(buffer)))
                    }
                    Err() -> {
                        io.formatln("[ERROR] Failed to load file '{}'", [file.slice()])
                    }
                }
            }
        }

        if self.buffers.count() == 0 {
            self.current_buffer = Buffer.scratch()
            self.buffers.add(self.current_buffer.clone())
            tabs.add(Tab.new(View.new(self.current_buffer.clone())))
        } else {
            self.current_buffer = self.buffers[0].clone()
        }

        self.register_command("view.left", [CommandStep.Key(KeyEvent(.None, .Left))])
        self.register_command("editor.save", [CommandStep.Key(KeyEvent(.Control, .Char('s')))])
        self.register_command("view.delete_line", [CommandStep.Key(KeyEvent(.None, .Char('d'))), CommandStep.Key(KeyEvent(.None, .Char('d')))])
    }

    register_command :: (&mut Self, command: string, steps: []CommandStep) {
        self.command_parsers.add(Rc[CommandParser].new(CommandParser.from_slice(command, steps)))
    }

    get_window_dim :: (&Self) -> (cols: int, rows: int) {
        rows := int(self.window_pixel_size.y / self.character_size.y)

        mut scale := self.character_size.x * (self.window_pixel_size.y / (self.character_size.y * f32(rows)))

        return int(self.window_pixel_size.x / scale), rows
    }

    set_font :: (&mut Self, path: string) {
        self.commands.push(.ChangeFont(path.to_owned()))
    }

    set_font_size :: (&mut Self, size: f32) {
        self.commands.push(.ChangeFontSize(size))
    }

    update :: (&mut Self) {
        if self.key_events.count() > 0 {
            self.parser_fiber.resume()
        }

        mut font_changed := false
        mut rerender := false

        while self.commands.count() > 0 {
            match self.commands.pop() {
                .ChangeFontSize($size) -> {
                    if size >= 10 {
                        self.font_size = size
                        font_changed = true
                    }
                }

                .ChangeFont($path) -> {
                    self.current_font.clear()
                    fmt.format_into(&mut self.current_font, "fonts/{}", [path])
                    font_changed = true
                }

                .TabNext -> {
                    self.active_tab = (self.active_tab + 1) % self.tabs.count()
                }

                .TabPrev -> {
                    self.active_tab = (self.active_tab - 1 + self.tabs.count()) % self.tabs.count()
                }
            }
        }

        if font_changed {
            iio := imgui.GetIO()
            iio.Fonts.Clear()
            font := iio.Fonts.AddFontFromFileTTF(self.current_font.as_cstring(), self.font_size, null, null)
            iio.Fonts.Build()
            ImGui_ImplOpenGL3_DestroyFontsTexture()
            ImGui_ImplOpenGL3_CreateFontsTexture()
            self.character_size = font.CalcTextSizeA(self.font_size, f32.max, -1, "#", null, null)
        }

        self.active_tab = self.active_tab.clamp(0, self.tabs.count() - 1)


        // @temp
        rerender = true

        if rerender {
            cols, rows := self.get_window_dim()

            // clear right-most column
            for r in 0 .. rows {
                *self.slots[cols + r * SLOTS_X] = Slot('`0', .Default, .Background)
            }

            self.render_tab_bar(0)

            self.render_tab(self.tabs[self.active_tab].get(), (0, 1), (cols, rows - 2))

            self.render_status_line(rows - 2)
            self.render_command_line(rows - 1)
        }
    }
}