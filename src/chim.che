#lib("./../icons/icon.res")

use import std.rc
use import std.box
use import std.string
use import std.array
use import std.ring_queue
use import std.unicode
use import std.mem.std_heap_allocator

mem :: import std.mem.allocator
io  :: import std.io
fmt :: import std.fmt
C   :: import std.c

use import glfw
use import glfw_hl

use import imgui_hl
use import imgui_opengl
imgui :: import imgui

use import editor
use import gap_buffer
use import editor_input
use import editor_render
use import clipboard
use import commands

vec2 :: imgui.ImVec2
vec4 :: imgui.ImVec4

vec2_zero : vec2 = vec2(0, 0)
vec4_zero : vec4 = vec4(0, 0, 0, 0)

#export_scope

SLOTS_X :: 2048
SLOTS_Y :: 2048

Slot :: struct {
    c   : char
    fg  : PaletteIndex
    bg  : PaletteIndex
    col : int = 0
}

Mode :: enum #copy {
    Normal
    Insert
    Visual
}

CursorType :: enum #copy {
    Line
    Full
    Underscore
}


Chim :: struct {
    slots           : []mut Slot
    /// path of this executable
    exe_path        := ".".to_owned()

    cursors         := Array[(col: int, row: int, typ: CursorType)].new()
    commands        := RingQueue[Command].new()
    last_move_command := Option[(count: int, command: MoveCommand)].None

    key_events      := Array[KeyEvent].new(20)

    // normal_mode
    n_normal_parsers    := Array[Rc[Parser]].new()
    n_move_parsers      := Array[Rc[Parser]].new()
    i_normal_parsers    := Array[Rc[Parser]].new()
    i_move_parsers      := Array[Rc[Parser]].new()
    v_normal_parsers    := Array[Rc[Parser]].new()
    v_move_parsers      := Array[Rc[Parser]].new()
    current_parser      := Option[Rc[Parser]].None

    // editor stuff
    current_mode    := Mode.Normal
    recording_macro := false

    tabs            := Array[Rc[Tab]].new()
    active_tab      := 0
    buffers         := Array[Rc[Buffer]].new()
    current_buffer  := Rc[Buffer].empty()

    window_pixel_size   := vec2(0, 0)
    has_focus           := false

    // settings
    wrapping_enabled    := true
    highlight_curr_line := true
    line_number_mode    := LineNumberMode.RelativeCursor
    show_whitespace     := true
    tab_width           := 4
    cursor_margin       := 0
    use_tab_char        := false

    // modifiers, keys, etc.
    current_mods_l  := GlfwMod.None
    current_mods_r  := GlfwMod.None
    current_mods    := GlfwMod.None

    // font stuff
    current_font    := String.empty()
    font_size       := 16.0f
    character_size  := vec2(21, 16)

    // theme stuff
    palette         := Palette.dark()

    // debug stuff
    vsync               := true
    show_debug_window   := false
    show_demo_window    := false
}

impl Drop for Chim {
    drop :: (&Self) {
        mem.free_n(self.slots)
    }
}

impl Chim {
    new :: () -> Chim {
        slots := mem.alloc_n(Slot, SLOTS_X * SLOTS_Y)
        C.memset(cast slots.data, 0, cast @sizeof(Slot) * slots.length)
        return Chim(
            slots = slots
        )
    }

    on_framebuffer_resize :: (&mut Self, width: f32, height: f32) {
        self.window_pixel_size = vec2(width, height)
    }

    on_focus :: (&mut Self, focused: i32) {
        if focused == 0 {
            current_mods_l = .None
            current_mods_r = .None
            current_mods = current_mods_l or current_mods_r
        }
    }

    on_iconify :: (&mut Self, iconified: i32) {
        if iconified != 0 {
            current_mods_l = .None
            current_mods_r = .None
            current_mods = current_mods_l or current_mods_r
        }
    }

    initialize :: (&mut Self, exe_path: String, args: []String) {
        self.exe_path = exe_path
        for row in 0 .. SLOTS_X {
            for col in 0 .. SLOTS_Y {
                *self.slots[col + row * SLOTS_X] = Slot('Â´', .Comment, .Background)
            }
        }

        self.set_font("FiraMono-Regular.ttf")
        self.set_font_size(18.5f)

        if args.length > 0 {
            for &file in args {
                match Buffer.from_file(file.slice()) {
                    Ok($buffer) -> {
                        self.buffers.add(buffer.clone())
                        tabs.add(Tab.new(View.new(buffer)))
                    }
                    Err() -> {
                        io.formatln("[ERROR] Failed to load file '{}'", [file.slice()])
                    }
                }
            }
        }

        if self.buffers.count() == 0 {
            self.current_buffer = Buffer.scratch()
            self.buffers.add(self.current_buffer.clone())
            tabs.add(Tab.new(View.new(self.current_buffer.clone())))
        } else {
            self.current_buffer = self.buffers[0].clone()
        }

        { // normal mode key bindings
            // move commands
            self.register_move_command(.Normal, "move.left", [], [KeyParser.new(.Left)])
            self.register_move_command(.Normal, "move.right", [], [KeyParser.new(.Right)])
            self.register_move_command(.Normal, "move.up", [], [KeyParser.new(.Up)])
            self.register_move_command(.Normal, "move.down", [], [KeyParser.new(.Down)])
            self.register_move_command(.Normal, "move.line_home", [], [KeyParser.new(.Home)])
            self.register_move_command(.Normal, "move.line_end", [], [KeyParser.new(.End)])
            self.register_move_command(.Normal, "move.buffer_home", [], [KeyParser.new(.Home, .Control)])
            self.register_move_command(.Normal, "move.buffer_end", [], [KeyParser.new(.End, .Control)])
            self.register_move_command(.Normal, "move.page_up", [], [KeyParser.new(.PageUp)])
            self.register_move_command(.Normal, "move.page_down", [], [KeyParser.new(.PageDown)])
            self.register_move_command(.Normal, "move.select_left", [], [KeyParser.new(.Left, .Shift)])
            self.register_move_command(.Normal, "move.select_right", [], [KeyParser.new(.Right, .Shift)])
            self.register_move_command(.Normal, "move.select_up", [], [KeyParser.new(.Up, .Shift)])
            self.register_move_command(.Normal, "move.select_down", [], [KeyParser.new(.Down, .Shift)])
            self.register_move_command(.Normal, "move.select_line_home", [], [KeyParser.new(.Home, .Shift)])
            self.register_move_command(.Normal, "move.select_line_end", [], [KeyParser.new(.End, .Shift)])
            self.register_move_command(.Normal, "move.select_buffer_home", [], [KeyParser.new(.Home, .Control or .Shift)])
            self.register_move_command(.Normal, "move.select_buffer_end", [], [KeyParser.new(.End, .Control or .Shift)])
            self.register_move_command(.Normal, "move.select_page_up", [], [KeyParser.new(.PageUp, .Shift)])
            self.register_move_command(.Normal, "move.select_page_down", [], [KeyParser.new(.PageDown, .Shift)])
            self.register_move_command(.Normal, "move.goto_line_absolute", [], [KeyParser.new(.Char('g')), KeyParser.new(.Char('l'))])
            self.register_move_command(.Normal, "move.goto_line_relative_top", [], [KeyParser.new(.Char('g')), KeyParser.new(.Char('t'))])
            self.register_move_command(.Normal, "move.goto_char", ["arg"], [KeyParser.new(.Char('f')), CharParser.new("arg")])
            self.register_move_command(.Normal, "move.goto_char_back", ["arg"], [KeyParser.new(.Char('f'), .Shift), CharParser.new("arg")])
            self.register_move_command(.Normal, "move.go_before_char", ["arg"], [KeyParser.new(.Char('t')), CharParser.new("arg")])
            self.register_move_command(.Normal, "move.go_before_char_back", ["arg"], [KeyParser.new(.Char('t'), .Shift), CharParser.new("arg")])
            self.register_move_command(.Normal, "move.repeat", [], [KeyParser.new(.Char(','))])
            self.register_move_command(.Normal, "move.repeat_inv", [], [KeyParser.new(.Char(';'))])

            // alternative key bindings
            self.register_command(.Normal, "move.buffer_home", [], [KeyParser.new(.Char('g')), KeyParser.new(.Char('h'))])
            self.register_command(.Normal, "move.buffer_end", [], [KeyParser.new(.Char('g')), KeyParser.new(.Char('e'))])

            // editor commands
            self.register_command(.Normal, "editor.tab_next", [], [KeyParser.new(.Tab, .Control)])
            self.register_command(.Normal, "editor.tab_prev", [], [KeyParser.new(.Tab, .Control or .Shift)])
            self.register_command(.Normal, "editor.buffer_save", [], [KeyParser.new(.Char('s'), .Control)])
            self.register_command(.Normal, "editor.mode_insert", [], [KeyParser.new(.Char('i'))])

            // buffer commands
            self.register_command(.Normal, "buffer.delete_left", [], [KeyParser.new(.Backspace)])
            self.register_command(.Normal, "buffer.delete_right", [], [KeyParser.new(.Delete)])
            self.register_command(.Normal, "buffer.delete_line", [], [KeyParser.new(.Char('d')), KeyParser.new(.Char('d'))])
            self.register_command(.Normal, "buffer.indent_line", [], [KeyParser.new(.Tab)])
            self.register_command(.Normal, "buffer.deindent_line", [], [KeyParser.new(.Tab, .Shift)])
            self.register_command(.Normal, "buffer.undo", [], [KeyParser.new(.Char('z'), .Control)])
            self.register_command(.Normal, "buffer.redo", [], [KeyParser.new(.Char('y'), .Control)])
            self.register_command(.Normal, "buffer.copy", [], [KeyParser.new(.Char('c'), .Control)])
            self.register_command(.Normal, "buffer.paste", [], [KeyParser.new(.Char('v'), .Control)])

            // view commands
            self.register_command(.Normal, "view.add_cursor_above", [], [KeyParser.new(.Up, .Shift or .Alt)])
            self.register_command(.Normal, "view.add_cursor_below", [], [KeyParser.new(.Down, .Shift or .Alt)])
        }

        { // insert mode key bindings
            // move commands
            self.register_move_command(.Insert, "move.left", [], [KeyParser.new(.Left)])
            self.register_move_command(.Insert, "move.right", [], [KeyParser.new(.Right)])
            self.register_move_command(.Insert, "move.up", [], [KeyParser.new(.Up)])
            self.register_move_command(.Insert, "move.down", [], [KeyParser.new(.Down)])
            self.register_move_command(.Insert, "move.line_home", [], [KeyParser.new(.Home)])
            self.register_move_command(.Insert, "move.line_end", [], [KeyParser.new(.End)])
            self.register_move_command(.Insert, "move.buffer_home", [], [KeyParser.new(.Home, .Control)])
            self.register_move_command(.Insert, "move.buffer_end", [], [KeyParser.new(.End, .Control)])
            self.register_move_command(.Insert, "move.page_up", [], [KeyParser.new(.PageUp)])
            self.register_move_command(.Insert, "move.page_down", [], [KeyParser.new(.PageDown)])
            self.register_move_command(.Insert, "move.select_left", [], [KeyParser.new(.Left, .Shift)])
            self.register_move_command(.Insert, "move.select_right", [], [KeyParser.new(.Right, .Shift)])
            self.register_move_command(.Insert, "move.select_up", [], [KeyParser.new(.Up, .Shift)])
            self.register_move_command(.Insert, "move.select_down", [], [KeyParser.new(.Down, .Shift)])
            self.register_move_command(.Insert, "move.select_line_home", [], [KeyParser.new(.Home, .Shift)])
            self.register_move_command(.Insert, "move.select_line_end", [], [KeyParser.new(.End, .Shift)])
            self.register_move_command(.Insert, "move.select_buffer_home", [], [KeyParser.new(.Home, .Control or .Shift)])
            self.register_move_command(.Insert, "move.select_buffer_end", [], [KeyParser.new(.End, .Control or .Shift)])
            self.register_move_command(.Insert, "move.select_page_up", [], [KeyParser.new(.PageUp, .Shift)])
            self.register_move_command(.Insert, "move.select_page_down", [], [KeyParser.new(.PageDown, .Shift)])

            // editor commands
            self.register_command(.Insert, "editor.tab_next", [], [KeyParser.new(.Tab, .Control)])
            self.register_command(.Insert, "editor.tab_prev", [], [KeyParser.new(.Tab, .Control or .Shift)])
            self.register_command(.Insert, "editor.buffer_save", [], [KeyParser.new(.Char('s'), .Control)])
            self.register_command(.Insert, "editor.mode_normal", [], [KeyParser.new(.Char('e'), .Control)])
            self.register_command(.Insert, "editor.mode_normal", [], [KeyParser.new(.Escape)])

            // buffer commands
            self.register_command(.Insert, "buffer.delete_left", [], [KeyParser.new(.Backspace)])
            self.register_command(.Insert, "buffer.delete_right", [], [KeyParser.new(.Delete)])
            self.register_command(.Insert, "buffer.insert_tab", [], [KeyParser.new(.Tab)])
            self.register_command(.Insert, "buffer.undo", [], [KeyParser.new(.Char('z'), .Control)])
            self.register_command(.Insert, "buffer.redo", [], [KeyParser.new(.Char('y'), .Control)])
            self.register_command(.Insert, "buffer.copy", [], [KeyParser.new(.Char('c'), .Control)])
            self.register_command(.Insert, "buffer.paste", [], [KeyParser.new(.Char('v'), .Control)])
            self.register_command(.Insert, "buffer.insert_char", ["ch"], [CharParser.new("ch")])
            self.register_command(.Insert, "buffer.insert_char", ["' '"], [KeyParser.new(.Space, .Shift)])
            self.register_command(.Insert, "buffer.insert_char", ["'`n'"], [KeyParser.new(.Enter)])

            // view commands
            self.register_command(.Insert, "view.add_cursor_above", [], [KeyParser.new(.Up, .Shift or .Alt)])
            self.register_command(.Insert, "view.add_cursor_below", [], [KeyParser.new(.Down, .Shift or .Alt)])
        }
    }

    register_command :: (&mut Self, mode: Mode, command: string, args: []string, steps: []Rc[Parser]) {
        match mode {
            .Normal -> self.n_normal_parsers.add(SequenceParser.new(command, args, steps))
            .Insert -> self.i_normal_parsers.add(SequenceParser.new(command, args, steps))
            .Visual -> self.v_normal_parsers.add(SequenceParser.new(command, args, steps))
        }
    }

    register_move_command :: (&mut Self, mode: Mode, command: string, args: []string, steps: []Rc[Parser]) {
        match mode {
            .Normal -> self.n_move_parsers.add(SequenceParser.new(command, args, steps))
            .Insert -> self.i_move_parsers.add(SequenceParser.new(command, args, steps))
            .Visual -> self.v_move_parsers.add(SequenceParser.new(command, args, steps))
        }
    }

    get_window_dim :: (&Self) -> (cols: int, rows: int) {
        rows := int(self.window_pixel_size.y / self.character_size.y)

        mut scale := self.character_size.x * (self.window_pixel_size.y / (self.character_size.y * f32(rows)))

        return int(self.window_pixel_size.x / scale), rows
    }

    set_font :: (&mut Self, path: string) {
        self.commands.push(Command(1, .ChangeFont(path.to_owned())))
    }

    set_font_size :: (&mut Self, size: f32) {
        self.commands.push(Command(1, .ChangeFontSize(size)))
    }

    update :: (&mut Self) {
        mut font_changed := false
        mut rerender := false

        while self.commands.count() > 0 {
            command := self.commands.pop()

            match &command.typ {
                .ChangeFontSize($size) -> {
                    if *size >= 10 {
                        self.font_size = *size
                        font_changed = true
                    }
                }

                .ChangeFont($path) -> {
                    self.current_font.clear()
                    fmt.format_into(&mut self.current_font, "{}/fonts/{}", [self.exe_path.slice(), path])
                    font_changed = true
                }

                $cmd -> {
                    self.execute_command(command.count, &command.typ)
                }
            }
        }

        if font_changed {
            iio := imgui.GetIO()
            iio.Fonts.Clear()
            font := iio.Fonts.AddFontFromFileTTF(self.current_font.as_cstring(), self.font_size, null, null)
            iio.Fonts.Build()
            ImGui_ImplOpenGL3_DestroyFontsTexture()
            ImGui_ImplOpenGL3_CreateFontsTexture()
            self.character_size = font.CalcTextSizeA(self.font_size, f32.max, -1, "#", null, null)
        }

        self.active_tab = self.active_tab.clamp(0, self.tabs.count() - 1)


        // @temp
        rerender = true

        if rerender {
            cols, rows := self.get_window_dim()

            // clear right-most column
            for r in 0 .. rows {
                *self.slots[cols + r * SLOTS_X] = Slot('`0', .Default, .Background)
            }

            self.render_tab_bar(0)

            self.render_tab(self.tabs[self.active_tab].get(), (0, 1), (cols, rows - 2))

            self.render_status_line(rows - 2)
            self.render_command_line(rows - 1)
        }
    }
}