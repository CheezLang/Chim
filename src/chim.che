use import std.rc
use import std.box
use import std.string
use import std.array
use import std.ring_queue
use import std.unicode
use import std.mem.std_heap_allocator

mem :: import std.mem.allocator
io  :: import std.io
fmt :: import std.fmt
C   :: import std.c

use import glfw
use import glfw_hl

use import imgui_hl
use import imgui_opengl
imgui :: import imgui

use import editor
use import gap_buffer
use import editor_input
use import editor_render

vec2 :: imgui.ImVec2
vec4 :: imgui.ImVec4

vec2_zero : vec2 = vec2(0, 0)
vec4_zero : vec4 = vec4(0, 0, 0, 0)

#export_scope

SLOTS_X :: 2048
SLOTS_Y :: 2048

Slot :: struct {
    c   : char
    fg  : PaletteIndex
    bg  : PaletteIndex
    col : int = 0
}

MoveCommand :: enum {
    Left, Right, Up, Down
    GoToLineAbsolute
    GoToLineRelativeTop
    Home, End
    BufferHome, BufferEnd
    PageUp, PageDown
    ViewGoToChar        : char
    ViewGoBeforeChar    : char
}

CommandType :: enum {
    Move            : MoveCommand
    SwitchMode      : Mode
    ChangeFontSize  : f32
    ChangeFont      : String
    TabNext, TabPrev
    DeleteLeft, DeleteRight
    DeleteLine
    BufferSave
}

Command :: struct {
    count   : int
    typ     : CommandType
}

Mode :: enum #copy {
    Normal
    Insert
    Visual
}

CursorType :: enum #copy {
    Line
    Full
    Underscore
}

// <move>   `Left`       -> view.move_cursor_left
// <normal> i            -> editor.enter_insert_mode
// <move>   i{c: char}   -> view.move_inside c
// <normal> f{c: char}   -> view.move_cursor_to c
// <normal> d{m: mov}    -> view.delete_moved_range m
// <normal> gd{c: char}{m: mov} -> view.delete_all_occurances_of c m

// gdx{Left}    -> view.delete_all_occurances_of 'x' view.move_cursor_left
// gdyfl        -> view.delete_all_occurances_of 'y' (view.move_cursor_to 'l')



Chim :: struct {
    slots           : []mut Slot
    /// path of this executable
    exe_path        := ".".to_owned()

    cursors         := Array[(col: int, row: int, typ: CursorType)].new()
    commands        := RingQueue[Command].new()

    key_events      := Array[KeyEvent].new(20)

    // normal_mode
    n_normal_parsers    := Array[Rc[Parser]].new()
    n_move_parsers      := Array[Rc[Parser]].new()
    i_normal_parsers    := Array[Rc[Parser]].new()
    i_move_parsers      := Array[Rc[Parser]].new()
    v_normal_parsers    := Array[Rc[Parser]].new()
    v_move_parsers      := Array[Rc[Parser]].new()
    current_parser      := Option[Rc[Parser]].None

    // editor stuff
    current_mode    := Mode.Normal
    recording_macro := false

    tabs            := Array[Rc[Tab]].new()
    active_tab      := 0
    buffers         := Array[Rc[Buffer]].new()
    current_buffer  := Rc[Buffer].empty()

    window_pixel_size   := vec2(0, 0)
    has_focus           := false

    // settings
    wrapping_enabled    := true
    highlight_curr_line := true
    line_number_mode    := LineNumberMode.RelativeCursor
    show_whitespace     := true
    tab_width           := 4
    cursor_margin       := 0

    // modifiers, keys, etc.
    current_mods_l  := GlfwMod.None
    current_mods_r  := GlfwMod.None
    current_mods    := GlfwMod.None

    // font stuff
    current_font    := String.empty()
    font_size       := 16.0f
    character_size  := vec2(21, 16)

    // theme stuff
    palette         := Palette.dark()

    // debug stuff
    vsync               := true
    show_debug_window   := false
    show_demo_window    := false
}

impl Drop for Chim {
    drop :: (&Self) {
        mem.free_n(self.slots)
    }
}

impl Chim {
    new :: () -> Chim {
        slots := mem.alloc_n(Slot, SLOTS_X * SLOTS_Y)
        C.memset(cast slots.data, 0, cast @sizeof(Slot) * slots.length)
        return Chim(
            slots = slots
        )
    }

    on_framebuffer_resize :: (&mut Self, width: f32, height: f32) {
        self.window_pixel_size = vec2(width, height)
    }

    on_focus :: (&mut Self, focused: i32) {
        if focused == 0 {
            current_mods_l = .None
            current_mods_r = .None
            current_mods = current_mods_l or current_mods_r
        }
    }

    on_iconify :: (&mut Self, iconified: i32) {
        if iconified != 0 {
            current_mods_l = .None
            current_mods_r = .None
            current_mods = current_mods_l or current_mods_r
        }
    }

    initialize :: (&mut Self, exe_path: String, args: []String) {
        self.exe_path = exe_path
        for row in 0 .. SLOTS_X {
            for col in 0 .. SLOTS_Y {
                *self.slots[col + row * SLOTS_X] = Slot('Â´', .Comment, .Background)
            }
        }

        self.set_font("FiraMono-Regular.ttf")
        self.set_font_size(18.5f)

        if args.length > 0 {
            for &file in args {
                match Buffer.from_file(file.slice()) {
                    Ok($buffer) -> {
                        self.buffers.add(buffer.clone())
                        tabs.add(Tab.new(View.new(buffer)))
                    }
                    Err() -> {
                        io.formatln("[ERROR] Failed to load file '{}'", [file.slice()])
                    }
                }
            }
        }

        if self.buffers.count() == 0 {
            self.current_buffer = Buffer.scratch()
            self.buffers.add(self.current_buffer.clone())
            tabs.add(Tab.new(View.new(self.current_buffer.clone())))
        } else {
            self.current_buffer = self.buffers[0].clone()
        }

        { // normal mode key bindings
            // move commands
            self.register_move_command(.Normal, "move.left", [KeyParser.new(.Left)])
            self.register_move_command(.Normal, "move.right", [KeyParser.new(.Right)])
            self.register_move_command(.Normal, "move.up", [KeyParser.new(.Up)])
            self.register_move_command(.Normal, "move.down", [KeyParser.new(.Down)])
            self.register_move_command(.Normal, "move.line_home", [KeyParser.new(.Home)])
            self.register_move_command(.Normal, "move.line_end", [KeyParser.new(.End)])
            self.register_move_command(.Normal, "move.buffer_home", [KeyParser.new(.Home, .Control)])
            self.register_move_command(.Normal, "move.buffer_end", [KeyParser.new(.End, .Control)])
            self.register_move_command(.Normal, "move.page_up", [KeyParser.new(.PageUp)])
            self.register_move_command(.Normal, "move.page_down", [KeyParser.new(.PageDown)])
            self.register_move_command(.Normal, "move.goto_line_absolute", [KeyParser.new(.Char('g')), KeyParser.new(.Char('l'))])
            self.register_move_command(.Normal, "move.goto_line_relative_top", [KeyParser.new(.Char('g')), KeyParser.new(.Char('t'))])
    
            // alternative key bindings
            self.register_command(.Normal, "move.buffer_home", [KeyParser.new(.Char('g')), KeyParser.new(.Char('h'))])
            self.register_command(.Normal, "move.buffer_end", [KeyParser.new(.Char('g')), KeyParser.new(.Char('e'))])
    
            // editor commands
            self.register_command(.Normal, "editor.tab_next", [KeyParser.new(.Tab, .Control)])
            self.register_command(.Normal, "editor.tab_prev", [KeyParser.new(.Tab, .Control or .Shift)])
            self.register_command(.Normal, "editor.buffer_save", [KeyParser.new(.Char('s'), .Control)])
            self.register_command(.Normal, "editor.mode_insert", [KeyParser.new(.Char('i'))])

            // view commands
            self.register_command(.Normal, "view.delete_left", [KeyParser.new(.Backspace)])
            self.register_command(.Normal, "view.delete_right", [KeyParser.new(.Delete)])
            self.register_command(.Normal, "view.delete_line", [KeyParser.new(.Char('d')), KeyParser.new(.Char('d'))])
        }

        { // insert mode key bindings
            // move commands
            self.register_move_command(.Insert, "move.left", [KeyParser.new(.Left)])
            self.register_move_command(.Insert, "move.right", [KeyParser.new(.Right)])
            self.register_move_command(.Insert, "move.up", [KeyParser.new(.Up)])
            self.register_move_command(.Insert, "move.down", [KeyParser.new(.Down)])
            self.register_move_command(.Insert, "move.line_home", [KeyParser.new(.Home)])
            self.register_move_command(.Insert, "move.line_end", [KeyParser.new(.End)])
            self.register_move_command(.Insert, "move.buffer_home", [KeyParser.new(.Home, .Control)])
            self.register_move_command(.Insert, "move.buffer_end", [KeyParser.new(.End, .Control)])
            self.register_move_command(.Insert, "move.page_up", [KeyParser.new(.PageUp)])
            self.register_move_command(.Insert, "move.page_down", [KeyParser.new(.PageDown)])

            // editor commands
            self.register_command(.Insert, "editor.tab_next", [KeyParser.new(.Tab, .Control)])
            self.register_command(.Insert, "editor.tab_prev", [KeyParser.new(.Tab, .Control or .Shift)])
            self.register_command(.Insert, "editor.buffer_save", [KeyParser.new(.Char('s'), .Control)])
            self.register_command(.Insert, "editor.mode_normal", [KeyParser.new(.Char('e'), .Control)])
            self.register_command(.Insert, "editor.mode_normal", [KeyParser.new(.Escape)])

            // view commands
            self.register_command(.Insert, "view.delete_left", [KeyParser.new(.Backspace)])
            self.register_command(.Insert, "view.delete_right", [KeyParser.new(.Delete)])
        }
    }

    register_command :: (&mut Self, mode: Mode, command: string, steps: []Rc[Parser]) {
        match mode {
            .Normal -> self.n_normal_parsers.add(SequenceParser.new(command, steps))
            .Insert -> self.i_normal_parsers.add(SequenceParser.new(command, steps))
            .Visual -> self.v_normal_parsers.add(SequenceParser.new(command, steps))
        }
    }

    register_move_command :: (&mut Self, mode: Mode, command: string, steps: []Rc[Parser]) {
        match mode {
            .Normal -> self.n_move_parsers.add(SequenceParser.new(command, steps))
            .Insert -> self.i_move_parsers.add(SequenceParser.new(command, steps))
            .Visual -> self.v_move_parsers.add(SequenceParser.new(command, steps))
        }
    }

    get_window_dim :: (&Self) -> (cols: int, rows: int) {
        rows := int(self.window_pixel_size.y / self.character_size.y)

        mut scale := self.character_size.x * (self.window_pixel_size.y / (self.character_size.y * f32(rows)))

        return int(self.window_pixel_size.x / scale), rows
    }

    set_font :: (&mut Self, path: string) {
        self.commands.push(Command(1, .ChangeFont(path.to_owned())))
    }

    set_font_size :: (&mut Self, size: f32) {
        self.commands.push(Command(1, .ChangeFontSize(size)))
    }

    update :: (&mut Self) {
        mut font_changed := false
        mut rerender := false

        while self.commands.count() > 0 {
            command := self.commands.pop()
            match &command.typ {
                .ChangeFontSize($size) -> {
                    if *size >= 10 {
                        self.font_size = *size
                        font_changed = true
                    }
                }

                .ChangeFont($path) -> {
                    self.current_font.clear()
                    fmt.format_into(&mut self.current_font, "{}/fonts/{}", [self.exe_path.slice(), path])
                    font_changed = true
                }

                .SwitchMode($mode) -> {
                    self.current_mode = *mode
                }

                .BufferSave -> {
                    view := self.tabs[self.active_tab].get().get_active_view()
                    try_with(view.get().buffer.get().write_to_disk(), {
                        io.formatln("[ERROR] {}", [&err])
                    })
                }

                .TabNext -> {
                    for 0 .. command.count {
                        self.active_tab = (self.active_tab + 1) % self.tabs.count()
                    }
                }

                .TabPrev -> {
                    for 0 .. command.count {
                        self.active_tab = (self.active_tab - 1 + self.tabs.count()) % self.tabs.count()
                    }
                }

                .DeleteLine -> {
                    view := self.tabs[self.active_tab].get().get_active_view()
                    for 0 .. command.count {
                        view.get_mut().delete_line()
                    }
                }

                .DeleteLeft -> {
                    view := self.tabs[self.active_tab].get().get_active_view()
                    for 0 .. command.count {
                        view.get_mut().delete_at_cursor()
                    }
                }

                .DeleteRight -> {
                    view := self.tabs[self.active_tab].get().get_active_view()
                    for 0 .. command.count {
                        view.get_mut().move_cursor_column(1)
                        view.get_mut().delete_at_cursor()
                    }
            }

            .Move($move) -> {
                match move {
                        .Left -> {
                            view := self.tabs[self.active_tab].get().get_active_view()
                            for 0 .. command.count {
                                view.get_mut().move_cursor_column(-1)
                            }
                        }

                        .Right -> {
                            view := self.tabs[self.active_tab].get().get_active_view()
                            for 0 .. command.count {
                                view.get_mut().move_cursor_column(1)
                            }
                        }

                        .Up -> {
                            view := self.tabs[self.active_tab].get().get_active_view()
                            for 0 .. command.count {
                                view.get_mut().move_cursor_line(-1)
                            }
                        }

                        .Down -> {
                            view := self.tabs[self.active_tab].get().get_active_view()
                            for 0 .. command.count {
                                view.get_mut().move_cursor_line(1)
                            }
                        }

                        .Home -> {
                            view := self.tabs[self.active_tab].get().get_active_view()
                            for 0 .. command.count {
                                view.get_mut().move_cursor_column_beginning()
                            }
                        }

                        .End -> {
                            view := self.tabs[self.active_tab].get().get_active_view()
                            for 0 .. command.count {
                                view.get_mut().move_cursor_column_end()
                            }
                        }

                        .BufferHome -> {
                            view := self.tabs[self.active_tab].get().get_active_view()
                            for 0 .. command.count {
                                view.get_mut().move_cursor_beginning()
                            }
                        }

                        .BufferEnd -> {
                            view := self.tabs[self.active_tab].get().get_active_view()
                            for 0 .. command.count {
                                view.get_mut().move_cursor_end()
                            }
                        }

                        .PageUp -> {
                            view := self.tabs[self.active_tab].get().get_active_view()
                            for 0 .. command.count {
                                view.get_mut().move_cursor_line(-self.get_window_dim().rows / 2)
                            }
                        }

                        .PageDown -> {
                            view := self.tabs[self.active_tab].get().get_active_view()
                            for 0 .. command.count {
                                view.get_mut().move_cursor_line(self.get_window_dim().rows / 2)
                            }
                        }

                        .GoToLineAbsolute -> {
                            view := self.tabs[self.active_tab].get().get_active_view()
                            view.get_mut().set_cursor_line(command.count - 1)
                        }

                        .GoToLineRelativeTop -> {
                            view := self.tabs[self.active_tab].get().get_active_view()
                            view.get_mut().set_cursor_line(view.get().top_line + command.count - 1)
                        }

                        $cmd -> {
                            io.formatln("[ERROR] move command not implemented: {}", [&cmd])
                        }
                    }
                }

                $cmd -> {
                    io.formatln("[ERROR] command not implemented: {}", [&cmd])
                }
            }
        }

        if font_changed {
            iio := imgui.GetIO()
            iio.Fonts.Clear()
            font := iio.Fonts.AddFontFromFileTTF(self.current_font.as_cstring(), self.font_size, null, null)
            iio.Fonts.Build()
            ImGui_ImplOpenGL3_DestroyFontsTexture()
            ImGui_ImplOpenGL3_CreateFontsTexture()
            self.character_size = font.CalcTextSizeA(self.font_size, f32.max, -1, "#", null, null)
        }

        self.active_tab = self.active_tab.clamp(0, self.tabs.count() - 1)


        // @temp
        rerender = true

        if rerender {
            cols, rows := self.get_window_dim()

            // clear right-most column
            for r in 0 .. rows {
                *self.slots[cols + r * SLOTS_X] = Slot('`0', .Default, .Background)
            }

            self.render_tab_bar(0)

            self.render_tab(self.tabs[self.active_tab].get(), (0, 1), (cols, rows - 2))

            self.render_status_line(rows - 2)
            self.render_command_line(rows - 1)
        }
    }
}