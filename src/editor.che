use import std.rc
use import std.box
use import std.array
use import std.map
use import std.string
use import std.mem.arena_allocator

mem :: import std.mem.allocator
io :: import std.io
fs :: import std.io.fs

use import gap_buffer

#export_scope

Position :: struct #copy {
    line    : int = 0
    column  : int = 0
}

impl Position {
    less :: (Self, other: Position) -> bool #operator("<") {
        return self.line < other.line or (self.line == other.line and self.column < other.column)
    }

    less_equal :: (Self, other: Position) -> bool #operator("<=") {
        return self.line < other.line or (self.line == other.line and self.column <= other.column)
    }

    equal :: (Self, other: Position) -> bool #operator("==") {
        return self.line == other.line and self.column == other.column
    }

    greater :: (Self, other: Position) -> bool #operator(">") {
        return self.line > other.line or (self.line == other.line and self.column > other.column)
    }

    greater_equal :: (Self, other: Position) -> bool #operator(">=") {
        return self.line > other.line or (self.line == other.line and self.column >= other.column)
    }
}

BufferLine :: struct {
    characters : GapBuffer[char]
}

impl BufferLine {
    empty :: (allocator: &mem.Allocator) -> BufferLine {
        return BufferLine(
            characters = GapBuffer[char].new(128, allocator)
        )
    }

    from_string :: (text: string, allocator: &mem.Allocator) -> BufferLine {
        chars := GapBuffer[char].new(text.bytes.length, allocator)
        for c in text {
            chars.append(c, allocator)
        }
        return BufferLine(
            characters = chars
        )
    }

    get_text :: (&Self) -> String {
        text := String.with_capacity(self.characters.count())
        for c in &self.characters {
            text.append_char(c)
        }
        return text
    }

    get_text_from :: (&Self, index: int) -> String {
        @assert(index <= self.characters.count())
        text := String.with_capacity(self.characters.count() - index)
        for c in &self.characters {
            if it_index < index then continue
            text.append_char(c)
        }
        return text
    }

    erase_from :: (&Self, index: int) {
        @assert(index <= self.characters.count())

        self.characters.move_gap(self.characters.count())
        while self.characters.count() > index {
            self.characters.truncate()
        }
    }
}

BufferEdit :: enum {
    InsertText  : (id: int, pos: Position, text: String)
    DeleteText  : (id: int, start: Position, end: Position)
    InsertLine  : (id: int, line: int, text: String)
    DeleteLine  : (id: int, line: int)
    Group       : Array[BufferEdit]
}

BufferEditRanges :: enum {
    None
    One     : (start: Position, end: Position)
    Many    : Map[int, (start: Position, end: Position)]
}

impl BufferEdit {
    collect_ranges :: (&Self, map: &mut Map[int, (start: Position, end: Position)]) {
        match self {
            .InsertText($edit) -> map.set(edit.id, (edit.pos, edit.pos))
            .InsertLine($edit) -> map.set(edit.id, (Position(edit.line, 0), Position(edit.line, 0)))
            .DeleteText($edit) -> map.set(edit.id, (edit.start, edit.end))
            .DeleteLine($edit) -> map.set(edit.id, (Position(edit.line, 0), Position(edit.line, 0)))
            .Group($group) -> {
                for(reverse=true) &change in group[..] {
                    change.collect_ranges(map)
                }
            }
            _ -> @assert(false)
        }
    }

    get_ranges :: (&Self) -> BufferEditRanges {
        return match self {
            .InsertText($edit) -> BufferEditRanges.One(edit.pos, edit.pos)
            .InsertLine($edit) -> BufferEditRanges.One(Position(edit.line, 0), Position(edit.line, 0))
            .DeleteText($edit) -> BufferEditRanges.One(edit.start, edit.end)
            .DeleteLine($edit) -> BufferEditRanges.One(Position(edit.line, 0), Position(edit.line, 0))
            .Group($group) -> {
                mut map := Map[int, (start: Position, end: Position)].new()

                for(reverse=true) &change in group[..] {
                    change.collect_ranges(&mut map)
                }

                BufferEditRanges.Many(map)
            }
            _ -> @assert(false)
        }
    }

    get_range :: (&Self) -> (start: Position, end: Position) {
        return match self {
            .InsertText($edit) -> edit.pos, edit.pos
            .InsertLine($edit) -> Position(edit.line, 0), Position(edit.line, 0)
            .DeleteText($edit) -> edit.start, edit.end
            .DeleteLine($edit) -> Position(edit.line, 0), Position(edit.line, 0)
            .Group($group) -> {
                @assert(group.count() > 0)
                group[0].get_range().start, group.peek_last().get_range().end
            }
            _ -> @assert(false)
        }
    }
}

Buffer :: struct {
    allocator   : Rc[ArenaAllocator]
    file        : Option[String]
    lines       : GapBuffer[BufferLine]
    dirty       : bool

    undo_stack  : Array[BufferEdit]
    undo_temp   : Array[BufferEdit]
    redo_stack  : Array[BufferEdit]
}

impl Buffer {
    from_file :: (path: string) -> Result[Rc[Buffer], ()] {
        text := try_with(fs.read_file(path), { return Err() })

        megs := 1 + u64(text.get_length()) / (1024 * 1024 * 10)
        arena := Rc[ArenaAllocator].new(ArenaAllocator.new(1024 * 1024 * megs))
        allocator : &mem.Allocator = arena.get()

        // assume around 15 characters per line
        mut lines := GapBuffer[BufferLine].new(text.get_length() / 15, allocator)

        for line in text.slice().lines() {
            lines.append(BufferLine.from_string(line, allocator), allocator)
        }

        if lines.count() == 0 {
            lines.append(BufferLine.empty(allocator), allocator)
        }

        return Ok(Rc[Buffer].new(Buffer(
            allocator   = arena
            file        = Some(path.to_owned())
            lines       = lines
            dirty       = false
            undo_stack  = Array[BufferEdit].new()
            undo_temp   = Array[BufferEdit].new()
            redo_stack  = Array[BufferEdit].new()
        )))
    }

    scratch :: () -> Rc[Buffer] {
        arena := Rc[ArenaAllocator].new(ArenaAllocator.new(1024 * 1024))
        lines := GapBuffer[BufferLine].new(100, arena.get())

        lines.append(BufferLine.empty(arena.get()), arena.get())
        return Rc[Buffer].new(Buffer(
            allocator   = arena
            file        = .None
            lines       = lines
            dirty       = true
            undo_stack  = Array[BufferEdit].new()
            undo_temp   = Array[BufferEdit].new()
            redo_stack  = Array[BufferEdit].new()
        ))
    }

    write_to_disk :: (&Self) -> Result[(), String] {
        return match &self.file {
            None -> Err("Failed to write unnamed buffer to disc".to_owned())
            Some($path) -> {
                buffer := String.with_capacity(lines.count() * 100)
                for &line in &self.lines {
                    if it_index > 0 then buffer.append_char('`n')
                    for c in &line.characters {
                        buffer.append_char(c)
                    }
                }

                try(fs.write_file(path.slice(), buffer.slice()))
                @cast(&mut Self, self).dirty = false
                Ok()
            }
        }
    }

    get_line :: (&Self, line: int) -> Option[&BufferLine] {
        return if line >= 0 and line < self.lines.count() then Some(self.lines[line]) else None
    }

    get_text :: (&Self, start: Position, end: Position) -> String {
        if start.line == end.line {
            line := self.lines[start.line]
            mut result := String.with_capacity(end.column - start.column)
            for start.column .. end.column {
                result.append_char(*line.characters[it])
            }
            return result
        } else {
            first_line := self.lines[start.line]
            last_line := self.lines[end.line]
            mut result := String.with_capacity((first_line.characters.count() - start.column) + end.column + (end.line - start.line - 1) * 20)
            for start.column .. first_line.characters.count() {
                result.append_char(*first_line.characters[it])
            }
            result.append_char('`n')
            for it in (start.line + 1) .. end.line {
                for c in &self.lines[it].characters {
                    result.append_char(c)
                }

                result.append_char('`n')
            }
            for 0 .. end.column {
                result.append_char(*last_line.characters[it])
            }
            return result
        }
    }

    flush_changes :: (&mut Self) {
        for &change in self.undo_temp[..] {
            self.undo_stack.push(*change)
        }
        self.undo_temp.clear()
    }

    group_changes :: (&mut Self) {
        if self.undo_temp.count() == 1 {
            self.undo_stack.push(self.undo_temp.pop())
        } else if self.undo_temp.count() > 1 {
            changes := self.undo_temp <- Array[BufferEdit].new()
            self.undo_stack.push(BufferEdit.Group(changes))
        }
    }

    undo :: (&mut Self) -> BufferEditRanges {
        if undo_temp.count() == 0 and undo_stack.count() == 0 {
            return .None
        }

        edit := if self.undo_temp.count() > 0 {
            undo_temp.pop()
        } else {
            undo_stack.pop()
        }

        redo := self.edit(edit)
        ranges := redo.get_ranges()
        self.redo_stack.push(redo)
        return ranges
    }

    redo :: (&mut Self) -> BufferEditRanges {
        if redo_stack.count() == 0 {
            return .None
        }
        undo := self.edit(redo_stack.pop())
        ranges := undo.get_ranges()
        if self.undo_temp.count() > 0 {
            self.undo_temp.push(undo)
        } else {
            self.undo_stack.push(undo)
        }
        return ranges
    }

    edit :: (&mut Self, edit: BufferEdit) -> BufferEdit {
        return match edit {
            .InsertText(($id, $pos, $text)) -> {
                // io.formatln("InsertText({}, '{}')", [pos, text.slice()])
                mut line := pos.line
                mut column := pos.column

                mut rem := String.empty()
                for text.slice().lines() {
                    if it_index == 0 {
                        for ch in it {
                            self.lines[line].characters.insert(column, ch, self.allocator.get())
                            column += 1
                        }
                    } else {
                        prev_line := self.lines[line]
                        for column .. prev_line.characters.count() {
                            rem.append_char(prev_line.characters.erase(column))
                        }

                        line += 1
                        self.lines.insert(line, BufferLine.from_string(it, self.allocator.get()), self.allocator.get())
                        column = self.lines[line].characters.count()
                    }

                    for c in rem.slice() {
                        self.lines[line].characters.insert(column + it_index, c, self.allocator.get())
                    }
                }

                BufferEdit.DeleteText((id, pos, Position(line, column)))
            }

            .InsertLine(($id, $line, $text)) -> {
                // io.formatln("InsertLine({}, '{}')", [line, text.slice()])
                self.lines.insert(line, BufferLine.from_string(text.slice(), self.allocator.get()), self.allocator.get())
                BufferEdit.DeleteLine(id, line)
            }

            .DeleteText(($id, $start, $end)) -> {
                // io.formatln("DeleteText({}, {})", [start, end])
                deleted_text := self.get_text(start, end)

                first_line := self.lines[start.line]
                if start.line == end.line {
                    for start.column .. end.column {
                        first_line.characters.erase(start.column)
                    }
                } else {
                    for start.column .. first_line.characters.count() {
                        first_line.characters.erase(start.column)
                    }
                    for end.column .. self.lines[end.line].characters.count() {
                        ch := self.lines[end.line].characters.erase(end.column)
                        first_line.characters.insert(first_line.characters.count(), ch, self.allocator.get())
                    }
                    for it in (start.line + 1) ..= end.line {
                        self.lines.erase(start.line + 1)
                    }
                }

                // io.formatln("deleted text: '{}'", [deleted_text.slice()])
                BufferEdit.InsertText((id, start, deleted_text))
            }

            .DeleteLine(($id, $line)) -> {
                // io.formatln("DeleteLine({})", [line])
                deleted_text := self.lines[line].get_text()
                lines.erase(line)
                // io.formatln("deleted text: '{}'", [deleted_text.slice()])
                BufferEdit.InsertLine((id, line, deleted_text))
            }

            .Group($group) -> {
                mut inverse := Array[BufferEdit].new(group.count())
                while group.count() > 0 {
                    inverse.push(self.edit(group.pop()))
                }
                BufferEdit.Group(inverse)
            }

            $op -> {
                io.formatln("undo(): {} not implemented", [&op])
                BufferEdit.InsertLine((0, 0, String.empty()))
            }
        }
    }

    insert_line :: (&mut Self, line: int, text: string, id: int) {
        self.lines.insert(line, BufferLine.from_string(text, self.allocator.get()), self.allocator.get())

        self.undo_temp.push(.DeleteLine(id, line))
        self.redo_stack.clear()
        self.dirty = true
    }

    append_string :: (&mut Self, line: int, text: string, id: int) {
        if line < 0 or line >= self.lines.count() {
            io.formatln("[ERROR] trying to insert at {} into buffer with {} lines", [line, self.lines.count()])
            return
        }
        self.insert_string(line, self.lines[line].characters.count(), text, id)
    }

    insert_string :: (&mut Self, line: int, column: int, text: string, id: int) -> (start: Position, end: Position) {
        if line < 0 or line >= self.lines.count() {
            io.formatln("[ERROR] trying to insert at {}:{} into buffer with {} lines", [line, column, self.lines.count()])
            return (Position(line, column), Position(line, column))
        }

        undo := self.edit(BufferEdit.InsertText(id, Position(line, column), text.to_owned()))
        range := undo.get_range()
        self.undo_temp.push(undo)
        self.redo_stack.clear()
        self.dirty = true
        return range
    }

    insert_char :: (&mut Self, line: int, column: int, ch: char, id: int) {
        if line < 0 or line >= self.lines.count() {
            io.formatln("[ERROR] trying to insert at {}:{} into buffer with {} lines", [line, column, self.lines.count()])
            return
        }

        self.undo_temp.push(self.edit(BufferEdit.InsertText(id, Position(line, column), String.from_char(ch))))
        self.redo_stack.clear()
        self.dirty = true
    }

    erase_line :: (&mut Self, line: int, id: int) {
        if line < 0 or line >= self.lines.count() {
            io.formatln("[ERROR] trying to erase line {} in buffer with {} lines", [line, self.lines.count()])
            return
        }

        text := self.lines[line].get_text()
        self.lines.erase(line)
        if self.lines.count() == 0 {
            self.lines.insert(0, BufferLine.empty(self.allocator.get()), self.allocator.get())
        }

        self.undo_temp.push(.InsertLine(id, line, text))
        self.redo_stack.clear()
        self.dirty = true
    }

    erase_range :: (&mut Self, start: Position, end: Position, id: int) {
        self.undo_temp.push(self.edit(BufferEdit.DeleteText(id, start, end)))
        self.redo_stack.clear()
        self.dirty = true
    }

    erase_char :: (&mut Self, line: int, column: int, id: int) {
        if line < 0 or line >= self.lines.count() {
            io.formatln("[ERROR] trying to erase char at {}:{} in buffer with {} lines", [line, column, self.lines.count()])
            return
        }

        buffer_line := self.lines[line]
        text := String.from_char(buffer_line.characters.erase(column))

        self.undo_temp.push(.InsertText(id, Position(line, column), text))
        self.redo_stack.clear()
        self.dirty = true
    }
}

LineNumberMode :: enum #tag_type(i32) #repr("C") #copy {
    None
    Absolute
    RelativeCursor
    RelativeTop
}

Cursor :: struct #copy {
    start   : Position
    end     : Position
}

impl Cursor {
    at :: (pos: Position) -> Cursor {
        return Cursor(pos, pos)
    }

    range :: (start: Position, end: Position) -> Cursor {
        return Cursor(start, end)
    }

    empty :: (&Self) -> bool {
        return start.line == end.line and start.column == end.column
    }

    low :: (&Self) -> Position {
        return if start <= end then start else end
    }

    high :: (&Self) -> Position {
        return if start >= end then start else end
    }

    less :: (&Self, other: &Cursor) -> bool #operator("<") {
        return self.low() < other.low()
    }

    less_equal :: (&Self, other: &Cursor) -> bool #operator("<=") {
        return self.low() <= other.low()
    }

    equal :: (&Self, other: &Cursor) -> bool #operator("==") {
        return self.low() == other.low()
    }

    greater :: (&Self, other: &Cursor) -> bool #operator(">") {
        return self.low() > other.low()
    }

    greater_equal :: (&Self, other: &Cursor) -> bool #operator(">=") {
        return self.low() >= other.low()
    }
}

View :: struct {
    buffer              : Rc[Buffer]
    cursors             : Array[Cursor]

    top_line            : int = 0
    active_cursor       := 0

    line_number_mode    := Option[LineNumberMode].None
    wrapping_enabled    := Option[bool].None
    highlight_curr_line := Option[bool].None
    show_whitespace     := Option[bool].None
    tab_width           := Option[int].None
    cursor_margin       := Option[int].None
}

impl View {
    new :: (buffer: Rc[Buffer]) -> Rc[View] {
        mut cursors := Array[Cursor].new()
        cursors.add(Cursor.at(Position()))
        return Rc[View].new(View(buffer, cursors))
    }

    scroll_to_cursor :: (&mut Self, cols: int, rows: int, margin: int) {
        self.update_cursors()

        cursor := self.get_active_cursor()
        if cursor.start.line - self.top_line >= rows - margin - 1 {
            self.top_line = cursor.start.line - rows + margin + 1
        } else if cursor.start.line - self.top_line < margin {
            self.top_line = cursor.start.line - margin
        }
        if self.top_line < 0 {
            self.top_line = 0
        }
    }

    sort_cursors :: (&mut Self) {
        self.cursors.sort((a, b) => if a == b then 0 else if a < b then 1 else -1)
    }

    update_cursors :: (&mut Self) {
        for &mut c in self.cursors.slice_mut() {
            c.start = self.clamp_or_wrap_position(c.start, false)
            c.end = self.clamp_or_wrap_position(c.end, false)
        }
        self.merge_cursors()
    }

    clear_cursors :: (&mut Self) {
        mut cursor := self.get_active_cursor()
        self.cursors.clear()
        self.cursors.add(cursor)
        self.active_cursor = 0
    }

    merge_cursors :: (&mut Self) {
        if self.cursors.count() > 1 {
            self.sort_cursors()

            for {0 .. self.cursors.count() - 1}.reverse() {
                this := self.cursors[it]
                next := self.cursors[it + 1]
                if this.empty() and this.end == next.start {
                    self.cursors.remove_at(it)
                } else if next.empty() and this.end == next.start {
                    self.cursors.remove_at(it + 1)
                } else if self.cursors[it].end > self.cursors[it + 1].start {
                    self.cursors[it].end = self.cursors[it + 1].end
                    self.cursors.remove_at(it + 1)
                }
            }
        }
        self.active_cursor = self.active_cursor.clamp(0, self.cursors.count() - 1)
    }

    get_active_cursor :: (&Self) -> Cursor {
        if self.active_cursor >= self.cursors.count() {
            io.formatln("{}/{}", [self.active_cursor, self.cursors.count()])
        }
        return *self.cursors[self.active_cursor]
    }

    add_cursor_below :: (&mut Self) {
        self.update_cursors()
        last_cursor := self.cursors.peek_last().start
        if last_cursor.line < buffer.get().lines.count() - 1 {
            self.cursors.add(Cursor.at(Position(last_cursor.line + 1, last_cursor.column)))
        }
        self.active_cursor = self.cursors.count() - 1
    }

    undo :: (&mut Self) {
        match self.buffer.get_mut().undo() {
            .None -> {}
            .One($range) -> {
                self.clear_cursors()
                self.cursors[0].start = range.start
                self.cursors[0].end = range.end
            }
            .Many($ranges) -> {
                self.cursors.clear()
                for range in &ranges {
                    self.cursors.add(Cursor(range.value.start, range.value.end))
                }
                self.active_cursor = 0
                self.update_cursors()
            }
        }
    }

    redo :: (&mut Self) {
        match self.buffer.get_mut().redo() {
            .None -> {}
            .One($range) -> {
                self.clear_cursors()
                self.cursors[0].start = range.end
                self.cursors[0].end = range.end
            }
            .Many($ranges) -> {
                self.cursors.clear()
                for range in &ranges {
                    self.cursors.add(Cursor(range.value.start, range.value.end))
                }
                self.active_cursor = 0
                self.update_cursors()
            }
        }
    }

    get_selected_text :: (&Self) -> String {
        mut result := String.empty()

        for &c in self.cursors[..] {
            if it_index > 0 then result.append_char('`n')
            text := self.buffer.get().get_text(c.low(), c.high())
            result.append(&text)
        }

        return result
    }

    insert_string :: (&mut Self, text: string) {
        self.buffer.get_mut().flush_changes()
        self.update_cursors()

        mut lines := text.lines().collect()

        lines_per_cursor := if lines.count() % self.cursors.count() == 0 {
            lines.count() / self.cursors.count()
        } else {
            lines.count()
        }

        mut last_line := -1
        mut lines_added := 0
        mut columns_deleted := 0
        for &mut c in self.cursors.slice_mut() {
            text := if lines_per_cursor == lines.count() then text else {
                first_line_index := it_index * lines_per_cursor
                last_line_index  := (it_index + 1) * lines_per_cursor - 1
                begin := int(lines[first_line_index].bytes.data) - int(text.bytes.data)
                end   := int(lines[last_line_index].bytes.data) - int(text.bytes.data) + lines[last_line_index].bytes.length
                text[begin .. end]
            }

            if c.empty() {
                c.start.line += lines_added
                if c.start.line == last_line {
                    c.start.column -= columns_deleted
                } else {
                    columns_deleted = 0
                }
                range := self.buffer.get_mut().insert_string(c.start.line, c.start.column, text, it_index)

                c.start = range.end
                lines_added += range.end.line - range.start.line
            } else {
                mut low  := c.low()
                mut high := c.high()

                low.line += lines_added
                high.line += lines_added
                if low.line == high.line {
                    if low.line == last_line {
                        low.column -= columns_deleted
                        high.column -= columns_deleted
                    } else {
                        columns_deleted = 0
                    }
                } else {
                    if low.line == last_line {
                        low.column -= columns_deleted
                    }
                    columns_deleted = 0
                }
                last_line = low.line
                lines_added -= high.line - low.line
                columns_deleted += high.column - low.column

                self.buffer.get_mut().erase_range(low, high, it_index)
                range := self.buffer.get_mut().insert_string(low.line, low.column, text, it_index)

                c.start = range.end
                lines_added += range.end.line - range.start.line
            }

            c.end = c.start
        }

        self.merge_cursors()

        self.buffer.get_mut().group_changes()
    }

    insert_char :: (&mut Self, text: char) {
        self.buffer.get_mut().flush_changes()
        self.update_cursors()

        mut last_line := -1
        mut lines_deleted := 0
        mut columns_deleted := 0
        for &mut c in self.cursors.slice_mut() {
            if c.empty() {
                c.start.line -= lines_deleted
                if c.start.line == last_line {
                    c.start.column -= columns_deleted
                } else {
                    columns_deleted = 0
                }

                self.buffer.get_mut().insert_char(c.start.line, c.start.column, text, it_index)
                if text == '`n' {
                    c.start.line += 1
                    c.start.column = 0
                    lines_deleted -= 1
                } else {
                    c.start.column += 1
                }
            } else {
                mut low  := c.low()
                mut high := c.high()

                low.line -= lines_deleted
                high.line -= lines_deleted
                if low.line == high.line {
                    if low.line == last_line {
                        low.column -= columns_deleted
                        high.column -= columns_deleted
                    } else {
                        columns_deleted = 0
                    }
                } else {
                    if low.line == last_line {
                        low.column -= columns_deleted
                    }
                    columns_deleted = 0
                }
                last_line = low.line
                lines_deleted += high.line - low.line
                columns_deleted += high.column - low.column

                self.buffer.get_mut().erase_range(low, high, it_index)
                self.buffer.get_mut().insert_char(low.line, low.column, text, it_index)

                c.start = low

                if text == '`n' {
                    c.start.line += 1
                    c.start.column = 0
                    lines_deleted -= 1
                } else {
                    c.start.column += 1
                }
            }

            c.end = c.start
        }

        self.merge_cursors()

        self.buffer.get_mut().group_changes()
    }

    delete_line :: (&mut Self) {
        self.buffer.get_mut().flush_changes()
        self.update_cursors()

        mut last_line       := -1
        mut lines_deleted   := 0
        for &mut c in self.cursors.slice_mut() {
            mut low  := c.low()
            mut high := c.high()

            low.line -= lines_deleted
            high.line -= lines_deleted

            if low.line < last_line {
                if low.line == high.line {

                } else {
                    for {low.line + 1} ..= high.line {
                        self.buffer.get_mut().erase_line(low.line, it_index)
                        lines_deleted += 1
                    }
                }
            } else {
                for low.line ..= high.line {
                    self.buffer.get_mut().erase_line(low.line, it_index)
                    lines_deleted += 1
                }
            }

            last_line = low.line
            c.start = low
            c.end   = low
        }
        self.update_cursors()

        self.buffer.get_mut().group_changes()
    }

    delete_at_cursor :: (&mut Self) {
        self.buffer.get_mut().flush_changes()
        self.update_cursors()

        mut last_line := -1
        mut lines_deleted := 0
        mut columns_deleted := 0
        for &mut c in self.cursors.slice_mut() {
            if c.empty() {
                c.start.line -= lines_deleted
                if c.start.line == last_line {
                    c.start.column -= columns_deleted
                } else {
                    columns_deleted = 0
                }

                if c.start.column == 0 {
                    if c.start.line > 0 {
                        c.start.line -= 1
                        c.start.column = self.buffer.get().lines[c.start.line].characters.count()
                        self.buffer.get_mut().erase_range(Position(c.start.line, c.start.column), Position(c.start.line + 1, 0), it_index)
                        lines_deleted += 1

                        last_line = c.start.line
                    } else {
                        // no point in doing anything
                    }
                } else {
                    c.start.column -= 1
                    self.buffer.get_mut().erase_char(c.start.line, c.start.column, it_index)

                    columns_deleted += 1
                    last_line = c.start.line
                }

                c.end = c.start
            } else {
                mut low  := c.low()
                mut high := c.high()

                low.line -= lines_deleted
                high.line -= lines_deleted
                if low.line == high.line {
                    if low.line == last_line {
                        low.column -= columns_deleted
                        high.column -= columns_deleted
                    } else {
                        columns_deleted = 0
                    }
                } else {
                    if low.line == last_line {
                        low.column -= columns_deleted
                    }
                    columns_deleted = 0
                }
                last_line = low.line
                lines_deleted += high.line - low.line
                columns_deleted += high.column - low.column

                self.buffer.get_mut().erase_range(low, high, it_index)

                c.start = low
                c.end   = low
            }
        }
        self.merge_cursors()

        self.buffer.get_mut().group_changes()
    }

    move_cursor_beginning :: (&mut Self, select: bool = false) {
        mut cursor := *self.cursors[0]
        self.cursors.clear()
        cursor.start.line = 0
        cursor.start.column = 0
        if !select {
            cursor.end = cursor.start
        }
        self.cursors.add(cursor)
        self.active_cursor = 0
    }

    move_cursor_end :: (&mut Self, select: bool = false) {
        mut cursor := *self.cursors[0]
        self.cursors.clear()
        cursor.start.line = self.buffer.get().lines.count() - 1
        cursor.start.column = self.buffer.get().lines[cursor.start.line].characters.count()
        if !select {
            cursor.end = cursor.start
        }
        self.cursors.add(cursor)
        self.active_cursor = 0
    }

    move_cursor_column_beginning :: (&mut Self, select: bool = false) {
        for &mut c in self.cursors.slice_mut() {
            c.start = self.clamp_or_wrap_position(c.start, false)
            c.end = self.clamp_or_wrap_position(c.end, false)
            c.start.column = 0
            if !select {
                c.end = c.start
            }
        }
        self.update_cursors()
    }

    move_cursor_column_end :: (&mut Self, select: bool = false) {
        for &mut c in self.cursors.slice_mut() {
            c.start = self.clamp_or_wrap_position(c.start, false)
            c.end = self.clamp_or_wrap_position(c.end, false)
            line := self.buffer.get().lines[c.start.line]
            c.start.column = line.characters.count()
            if !select {
                c.end = c.start
            }
        }
        self.update_cursors()
    }

    move_cursor_column :: (&mut Self, columns: int, select: bool = false) {
        for &mut c in self.cursors.slice_mut() {
            c.start = self.clamp_or_wrap_position(Position(c.start.line, c.start.column + columns), true)
            if !select {
                c.end = c.start
            }
        }
        self.update_cursors()
    }

    move_cursor_line :: (&mut Self, lines: int, select: bool = false) {
        for &mut c in self.cursors.slice_mut() {
            c.start = self.clamp_or_wrap_position(Position(c.start.line + lines, c.start.column), false)
            if !select {
                c.end = c.start
            }
        }
        self.update_cursors()
    }

    set_cursor_line :: (&mut Self, line: int) {
        self.clear_cursors()
        self.cursors[0].start.line = line
        self.cursors[0].end = self.cursors[0].start
        self.update_cursors()
    }

    clamp_or_wrap_position :: (&Self, position: Position, wrap: bool) -> Position {
        buffer := self.buffer.get()
        if buffer.lines.count() == 0 {
            return Position(0, 0)
        } else if position.line < 0 {
            line := buffer.lines[0]
            if position.column < 0 {
                return Position(0, 0)
            } else if position.column > line.characters.count() {
                return Position(0, line.characters.count())
            } else {
                return Position(0, position.column)
            }
        } else if position.line >= buffer.lines.count() {
            line := buffer.lines[position.line - 1]
            if position.column < 0 {
                return Position(buffer.lines.count() - 1, 0)
            } else if position.column > line.characters.count() {
                return Position(buffer.lines.count() - 1, line.characters.count())
            } else {
                return Position(buffer.lines.count() - 1, position.column)
            }
        } else {
            // line is in range, wrap column
            line := buffer.lines[position.line]

            if wrap {
                if position.column < 0 {
                    if position.line > 0 {
                        return self.clamp_or_wrap_position(Position(
                            line    = position.line - 1
                            column  = position.column + buffer.lines[position.line - 1].characters.count() + 1
                        ), wrap)
                    } else {
                        return Position(position.line, 0)
                    }
                } else if position.column > line.characters.count() {
                    if position.line < buffer.lines.count() - 1 {
                        return self.clamp_or_wrap_position(Position(
                            line    =  position.line + 1
                            column  = position.column - line.characters.count() - 1
                        ), wrap)
                    } else {
                        return Position(position.line, line.characters.count())
                    }
                } else {
                    return position
                }
            } else {
                if position.column < 0 {
                    return Position(position.line, 0)
                } else if position.column > line.characters.count() {
                    return Position(position.line, line.characters.count())
                } else {
                    return position
                }
            }
        }
    }
}

Split :: enum {
    None        : Rc[View]
    Vertical    : Array[Rc[Split]]
    Horizontal  : Array[Rc[Split]]
}

Tab :: struct {
    split : Rc[Split]
}

impl Tab {
    new :: (view: Rc[View]) -> Rc[Tab] {
        return Rc[Tab].new(Tab(
            split = Rc[Split].new(Split.None(view))
        ))
    }

    get_active_view :: (&Self) -> Rc[View] {
        return match self.split.get() {
            .None($view) -> view.clone()
            _ -> @assert(false)
        }
    }
}